## 设计理念初稿

分析功能对应的逻辑要写在注释中.分析模式改为

- 智能分析
  (默认启用)将英文单词分格,中文整句分格,连着的数字一格,去除空格.每个标点占一格,
- 中文分析
  中英分离,空格,整句,符号分离.符号空格留在上字词尾,数字分格.剩余中文先查找字典,在调用算法.(查找字典和调用算法有开关)
  两种不启用时,每个字符拆成单字
- 英文分析
  中英分离,空格,符号,整句分离.符号空格留在上字词尾,数字分格.英文单词如果是类似命名 如"DarkSoul","dark_soul","dark-soul"都分成"dark" "soul".但是"DARKSOUL"大写字母连续的不拆
- 代码分析
  (不调用分出每一行的splitText函数,防止函数体不完整)主要考虑cpp和Python即可
  分为整句(宏整句如cpp的define,引入(improt ,#include)整句,定义或声明),函数体(成对符号()""{}[]''``<>.分成最大成对,内部不拆)

<!--如果不成对,判断不成对的符号,再先内而外分不成对部分的最小成对.{{print{dark soul}}拆成'{dark soul}','{print}','{'.//删除这个逻辑了,思路保留,以后思考-->

- 混沌文本
  按设定的行字符数,直接按字符硬断行
- AI分析
  分析出链接先输出,疑似链接补全再输出.剩下的严格分词
- 整句分析
  将文本拆成句子,再去除空格,中间不在分词.
- 去除符号
  先按符号分格,再去除符号,在按整句,空格,换行分离.再中,英,数字分离
- 随机分词
将所有字符随机分成1-10的字符串.从头到尾跑出来,支持刷新重跑
<!--考虑渐显按钮在刷新生成按钮旁  //删除这个逻辑了,思路保留,以后思考-->

多规则组合模仿多格式分析功能设计
提供下列选项,用户可以任意点击按钮,但是按一次就是处理一次.可以重复返回上一次结果.输出的面板仍然是分词面板
选项,一行两个有
符号分词(符号放在上词尾,除非是成对的符号的前一个)
空格,换行分词(放前一词词尾)
中英分词(分离中文和英文)
大写分词(将每个大写分开)
命名分词(各类命名法分格)
数字分词(数字单独分出来)
去除空格
去除符号
去除中文
去除英文

功能的对应的逻辑要写在注释中

设置选项要新增界面,中文分词是否启用词典,是否启用算法,ai的配置界面,混沌分词分词数设定,随机分词的字符数区间,命名分格是否去除符号(默认去除符号,不去符号多分出一格),

## 更正

.组合选项是处理的原始文本,不会对基础模式的结果处理.
代码分析,不带调用splitText函数.对python先可以按行分离,然后相同缩进的临行组合在一起.含{}符号的就当cpp没"{"符号的就按行分.如果有{就找最近的},组合成新的一行.不管成不成对
.不含{}和相同缩进组合行的就是整句.DarkSOUL处理成Dark SOUL,HTTPSConnection处理成HTTPSConnection,XMLHttpRequest为XMLHttp Request.可以重复返回上一次结果最多6次(你考虑合适的值,处理文本越大,返回次数越少).引入互斥组和依赖关系."去除符号" + "符号分词"文本保持在去除符号,相当于此时不操作.启用"去除中文" + "去除英文" + "去除数字".你只管运行和错误处理,不管操作结果怎样.大写分词是再将每个大写字母分成一格与命名分词不同.ai分析链接片段排在前面,根据上下文智能推断,Visit example.com or example.org两个都补全.修正逻辑：

### AI分析处理流水线

1. 链接识别阶段：提取所有URL模式（http://, https://, ftp://等）
2. 疑似链接识别：域名模式（example.com, example.org等）
3. 上下文补全阶段：根据最近完整链接的协议头补全疑似链接
4. 文本重组阶段：将原文本中的链接位置替换为占位符
5. 严格分词阶段：对非链接文本进行标准分词
6. 输出排序：链接片段（按出现顺序）→ 补全链接 → 分词结果
   边界处理：如果无上下文链接，example.org 默认补全为 https://example.org.修正逻辑：

### Python代码分析 - 缩进栈算法

1. 维护缩进栈：记录每一层的缩进空格数
2. 行分类：
   - 空行：跳过或作为分隔标记
   - 缩进增加：推入新栈层，开启新代码块
   - 缩进不变：延续当前代码块
   - 缩进减少：弹出栈层直到匹配，归属于匹配的父级块
3. 组合规则：同一栈层内的连续行组合为逻辑块
4. 函数体识别：包含 `:` 的行作为块头，后续同栈层行为体
   与C++区分逻辑：

### 代码类型检测

if '{' in text or '}' in text:
mode = 'cpp_brace' # 使用成对符号匹配
elif any(line.strip().endswith(':') for line in lines):
mode = 'python_indent' # 使用缩进栈算法
else:
mode = 'line_based' # 退化为整句分析.刷新生成 .
随机分词的结果不需要保存到历史栈.不可回溯.混沌分析改名为字符断行.设置是全局持久化.查看是否有缺陷,逻辑是否涵盖大部分需求了,如果可以了就输出一份严谨规范,满足我全部要求的细节md文档.和我的叙述风格一致.

---

## 完整功能规范文档

### 一、核心处理逻辑

#### 1.1 组合选项与基础模式的关系

- **组合选项**：直接处理原始文本，与基础模式互不干扰
- 执行组合选项时，不对基础模式的结果进行二次处理
- 用户可自由组合任意选项，按一次执行一次，不可叠加依赖

#### 1.2 选项互斥组

| 互斥组 | 选项                         | 说明             |
| ------ | ---------------------------- | ---------------- |
| A组    | 中文分析、英文分析           | 互斥，只能选其一 |
| B组    | 整句分析、混沌分析(字符断行) | 互斥，只能选其一 |
| C组    | 智能分析、代码分析           | 互斥，只能选其一 |

#### 1.3 选项依赖关系

| 依赖关系 | 主选项   | 依赖选项 | 说明                                           |
| -------- | -------- | -------- | ---------------------------------------------- |
| D1       | 命名分词 | 去除符号 | 命名分词默认去除符号                           |
| D2       | 大写分词 | 中英分词 | 大写分词需要先分离中英文                       |
| D3       | 符号分词 | 去除符号 | 符号分词与去除符号互斥时，文本保持去除符号状态 |
| D4       | AI分析   | 严格分词 | AI分析后的非链接部分仍需严格分词               |

#### 1.4 重复返回机制

- 刷新生成按钮最多返回6次上一次结果
- 处理文本越大，返回次数越少
- 计算公式：`maxReturns = Math.max(1, Math.floor(6 - (textLength / 5000)))`

---

### 二、代码分析模式

#### 2.1 代码类型检测逻辑

```
if '{' in text or '}' in text:
    mode = 'cpp_brace'       # 使用成对符号匹配
elif any(line.strip().endswith(':') for line in lines):
    mode = 'python_indent'   # 使用缩进栈算法
else:
    mode = 'line_based'      # 退化为整句分析
```

#### 2.2 C++代码分析 - 成对符号匹配算法

- **符号对**：`()`, `[]`, `{}`, `""`, `''`, ` `` `
- **处理步骤**：
  1. 按行分离文本
  2. 扫描所有`{`和`}`
  3. 对于每个`{`，找到最近的`}`（不论是否成对）
  4. 将`{`和`}`之间的内容组合成新的一行
  5. 不含`{}`的行按整句处理

#### 2.3 Python代码分析 - 缩进栈算法

- **数据结构**：`indentStack = [0]`（初始缩进为0）
- **行分类规则**：
  - 空行：跳过或作为分隔标记
  - 缩进增加（indent > stackTop）：推入新栈层
  - 缩进不变（indent == stackTop）：延续当前代码块
  - 缩进减少（indent < stackTop）：弹出栈层直到匹配
- **组合规则**：同一栈层内的连续非空行组合为逻辑块
- **函数体识别**：包含`:`的行作为块头，后续同栈层行为函数体

#### 2.4 整句识别规则

- 不含`{}`和相同缩进组合行的文本即为整句
- 整句处理方式：去除首尾空格，保留完整内容不再分词

#### 2.5 命名法处理

- `DarkSOUL` → `Dark SOUL`
- `HTTPSConnection` → `HTTPSConnection`（连续大写不拆分）
- `XMLHttpRequest` → `XMLHttp Request`

---

### 三、AI分析处理流水线

#### 3.1 处理阶段

```
阶段1：链接识别 → 提取URL模式（http://, https://, ftp://等）
阶段2：疑似链接识别 → 检测域名模式（example.com, example.org等）
阶段3：上下文补全 → 根据最近完整链接的协议头补全疑似链接
阶段4：文本重组 → 将原文本中的链接位置替换为占位符
阶段5：严格分词 → 对非链接文本进行标准分词
阶段6：输出排序 → 链接片段(按出现顺序) → 补全链接 → 分词结果
```

#### 3.2 链接补全规则

- `example.com` / `example.org`：默认补全为`https://example.com`或`https://example.org`
- 无上下文链接时，使用默认协议头`https://`
- 上下文中有`http://`链接时，后续疑似链接使用`http://`补全
- 上下文中有`https://`链接时，后续疑似链接使用`https://`补全

#### 3.3 域名模式识别

- 匹配正则：`[a-zA-Z0-9-]+\.(com|org|net|cn|io|cc|co)`
- 排除已知非链接词汇（如`www.`开头的视为完整链接而非疑似链接）

---

### 四、组合选项处理规则

#### 4.1 基础规则

- 所有组合选项直接作用于原始文本
- 不依赖基础模式的处理结果
- 执行顺序：从左到右依次处理

#### 4.2 特殊组合处理

| 组合                           | 处理结果                                   |
| ------------------------------ | ------------------------------------------ |
| 去除符号 + 符号分词            | 文本保持去除符号状态，等同于仅执行去除符号 |
| 去除中文 + 去除英文 + 去除数字 | 仅保留符号和空格                           |
| 去除中文 + 去除英文            | 仅保留数字、符号、中文标点                 |
| 大写分词 + 命名分词            | 分别执行，互不干扰                         |
| 去除空格 + 去除符号            | 先去除符号，再去除空格                     |

#### 4.3 大写分词规则

- 大写分词：将每个大写字母分成独立单元
- 与命名分词的区别：
  - 大写分词：`DarkSOUL` → `D` `a` `r` `k` `S` `O` `U` `L`
  - 命名分词：`DarkSOUL` → `Dark` `SOUL`（驼峰分割）

---

### 五、设置全局持久化

#### 5.1 持久化配置项

| 配置项            | 默认值 | 说明                   |
| ----------------- | ------ | ---------------------- |
| 字符断行-行字符数 | 100    | 每行最大字符数         |
| 随机分词-最小长度 | 1      | 最小分词长度           |
| 随机分词-最大长度 | 10     | 最大分词长度           |
| 重复返回次数上限  | 6      | 刷新生成的最大返回次数 |
| 启用词典          | true   | 中文分析是否启用词典   |
| 启用算法          | true   | 中文分析是否启用算法   |

#### 5.2 存储方式

- 使用`chrome.storage.local`进行全局持久化
- 配置变更时立即保存
- 扩展启动时自动加载上次配置

---

### 六、执行流程图

```
输入文本
    ↓
┌───────────────────────────────────────┐
│ 代码类型检测                           │
│ - 检测{}符号 → cpp_brace模式          │
│ - 检测:结尾 → python_indent模式       │
│ - 否则 → line_based模式               │
└───────────────────────────────────────┘
    ↓
┌───────────────────────────────────────┐
│ 模式分发                               │
│ - cpp_brace: 成对符号匹配              │
│ - python_indent: 缩进栈算法            │
│ - line_based: 整句分析                 │
└───────────────────────────────────────┘
    ↓
┌───────────────────────────────────────┐
│ 应用组合选项                           │
│ - 直接处理原始文本                     │
│ - 检查互斥组冲突                        │
│ - 解析依赖关系                          │
└───────────────────────────────────────┘
    ↓
┌───────────────────────────────────────┐
│ 输出处理结果                           │
│ - 返回结果数组                          │
│ - 记录历史栈（随机分词除外）            │
└───────────────────────────────────────┘
```

---

### 七、错误处理规范

#### 7.1 错误类型

| 错误码 | 说明           | 处理方式               |
| ------ | -------------- | ---------------------- |
| E001   | 文本为空       | 返回空数组             |
| E002   | 正则表达式错误 | 使用默认正则，输出警告 |
| E003   | 缩进解析异常   | 退化为整句分析         |
| E004   | 符号匹配异常   | 跳过异常行继续处理     |
| E005   | 内存超限       | 分批处理，返回部分结果 |

#### 7.2 错误日志

- 所有错误记录至控制台
- 严重错误显示用户提示
- 不影响扩展其他功能运行

---

### 八、测试用例

#### 8.1 Python代码测试

```python
def hello():
    print("Hello")
    if True:
        print("World")

class Test:
    def __init__(self):
        pass
```

期望输出：`["def hello():", 'print("Hello")', 'print("World")', "class Test:", "def __init__(self):", "pass"]`

#### 8.2 C++代码测试

```cpp
#include <iostream>
int main() {
    std::cout << "Hello";
    if (true) {
        std::cout << "World";
    }
}
```

期望输出：`["#include <iostream>", "int main() {", 'std::cout << "Hello";', 'std::cout << "World";', "}"]`

#### 8.3 链接补全测试

输入：`Visit example.com or example.org`
期望输出：`["https://example.com", "https://example.org"]`

输入：`Check http://test.com and example.net`
期望输出：`["http://test.com", "http://example.net"]`

---

### 九、实现优先级

#### 9.1 第一阶段（核心）

- 代码类型检测
- C++成对符号匹配
- Python缩进栈算法
- 整句识别规则

#### 9.2 第二阶段（功能）

- AI分析链接处理流水线
- 组合选项互斥组
- 组合选项依赖关系
- 重复返回机制

#### 9.3 第三阶段（优化）

- 随机分词（字符断行）
- 全局持久化配置
- 错误处理完善
- 性能优化
