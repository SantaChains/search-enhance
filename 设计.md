我将为您创建一份完整的项目升级文档，风格与您一致，涵盖所有细节逻辑。让我先分析您的需求并生成文档。

---

# 分词系统架构升级文档

## 设计理念

分析功能对应的逻辑要写在注释中。分析模式改为互斥的基础模式与可叠加的组合选项分离架构，确保处理流程清晰可追溯。

---

## 一、基础分析模式（互斥）

### 1.1 智能分析

```javascript
/**
 * 智能分析模式 - 默认启用
 *
 * 处理逻辑：
 * 1. 英文单词识别：/[a-zA-Z]+/ 连续字母作为单词单元
 * 2. 中文整句识别：/[\u4e00-\u9fa5]+/ 连续中文字符作为整句
 * 3. 数字合并：/\d+/ 连续数字作为一格
 * 4. 空格去除：/\s+/ 全部去除
 * 5. 标点处理：每个标点符号独立占一格
 *
 * 优先级顺序：中文整句 > 英文单词 > 数字 > 标点 > 其他字符
 *
 * 示例：
 * 输入："Hello世界123，test！"
 * 输出：["Hello", "世界", "123", "，", "test", "！"]
 */
function smartAnalysis(text) {
  // 实现逻辑...
}
```

### 1.2 中文分析

```javascript
/**
 * 中文分析模式
 *
 * 处理流程：
 * 1. 中英分离：中文[\u4e00-\u9fa5]与非中文分离
 * 2. 空格识别：/\s+/ 作为分隔标记，归属上词词尾
 * 3. 整句识别：连续中文字符构成候选整句
 * 4. 符号分离：标点符号独立处理，归属上词词尾
 * 5. 数字分格：/\d/ 每个数字独立（与智能分析不同）
 * 6. 中文分词：
 *    - 若启用词典：优先匹配词典词条（最长匹配）
 *    - 若启用算法：词典未命中时调用分词算法
 *    - 若都关闭：降级为单字拆分
 *
 * 降级机制：当词典开关与算法开关都关闭时，
 * 每个中文字符拆成单字，英文字母拆成单字符，
 * 数字拆成单字符，符号独立成格
 *
 * 设置项：settings.cnUseDict, settings.cnUseAlgo
 */
function chineseAnalysis(text, useDict, useAlgo) {
  // 实现逻辑...
}
```

### 1.3 英文分析

```javascript
/**
 * 英文分析模式
 *
 * 处理流程：
 * 1. 中英分离：中文与非中文分离
 * 2. 空格识别：/\s+/ 作为分隔，归属上词词尾
 * 3. 符号分离：标点独立，归属上词词尾
 * 4. 整句识别：连续非空格非符号字符
 * 5. 数字分格：/\d/ 每个数字独立
 * 6. 命名法分割：
 *    - 驼峰命名：DarkSoul → Dark, Soul
 *    - 蛇形命名：dark_soul → dark, soul（去除下划线）
 *    - 短横线命名：dark-soul → dark, soul（去除短横线）
 *    - 连续大写保留：DARKSOUL → DARKSOUL（不拆）
 *    - 混合处理：DarkSOUL → Dark, SOUL
 *    - HTTPSConnection → HTTPSConnection（连续大写视为整体）
 *    - XMLHttpRequest → XMLHttp, Request（小写后大写视为边界）
 *
 * 设置项：settings.namingRemoveSymbol（默认true，去除分隔符）
 */
function englishAnalysis(text, removeSymbol) {
  // 实现逻辑...
}
```

### 1.4 代码分析

```javascript
/**
 * 代码分析模式
 *
 * 核心原则：不调用splitText函数，防止函数体不完整
 *
 * 代码类型检测：
 * if (/{|}/.test(text)) mode = 'cpp_brace';
 * else if (lines.some(l => l.trim().endsWith(':'))) mode = 'python_indent';
 * else mode = 'line_based';
 *
 * C++处理（cpp_brace）：
 * 1. 整句识别：#include, #define, 前置声明（行级）
 * 2. 函数体识别：
 *    - 扫描所有{符号，找到最近的}符号
 *    - 将{...}内容组合成新行（不管是否真正成对）
 *    - 内部内容不拆分，保持完整
 * 3. 不含{}的行：作为整句处理
 *
 * Python处理（python_indent）：
 * 1. 维护缩进栈：indentStack = [0]
 * 2. 行分类：
 *    - 空行：跳过或作为分隔标记
 *    - 缩进增加（indent > stackTop）：推入新层，开启代码块
 *    - 缩进不变（indent == stackTop）：延续当前块
 *    - 缩进减少（indent < stackTop）：弹出栈层直到匹配
 * 3. 组合规则：同一栈层连续非空行组合为逻辑块
 * 4. 函数体识别：含:的行作为块头，后续同层行为体
 *
 * 退化处理（line_based）：
 * 不含{}且无法识别缩进模式的文本，按整句分析处理
 *
 * 引入整句边界：
 * - C++：#include <...>或"..."整行，#define到行尾（遇注释结束）
 * - Python：import单行，from...import多行（遇闭合括号或空行结束）
 */
function codeAnalysis(text) {
  // 代码类型检测
  const mode = detectCodeMode(text);

  switch (mode) {
    case "cpp_brace":
      return analyzeCpp(text);
    case "python_indent":
      return analyzePython(text);
    default:
      return sentenceAnalysis(text);
  }
}
```

### 1.5 字符断行（原混沌文本）

```javascript
/**
 * 字符断行模式
 *
 * 处理逻辑：
 * 1. 去除所有现有换行符
 * 2. 按settings.charBreakLength设定值严格切割
 * 3. 不考虑语义、单词边界、编码边界
 *
 * 编码安全：
 * - 使用Array.from(string)确保Unicode字符正确计数
 * - 避免在UTF-16代理对中间切断（如emoji）
 *
 * 示例（设定行字符数=5）：
 * 输入："Hello, 世界!"
 * Array.from → ['H','e','l','l','o',',',' ','世','界','!']
 * 结果：["Hello", ", 世界!"]
 *
 * 设置项：settings.charBreakLength（默认100，范围10-500）
 */
function charBreakLine(text, lineLength) {
  // 实现逻辑...
}
```

### 1.6 AI分析

```javascript
/**
 * AI分析模式
 *
 * 处理流水线：
 * 阶段1：链接识别 → 提取URL模式（https?://|ftp://等）
 * 阶段2：疑似链接识别 → 检测域名模式（[a-z0-9-]+\.(com|org|net|cn|io)）
 * 阶段3：上下文补全 → 根据最近完整链接的协议头补全疑似链接
 *         - 有上下文http:// → 补全为http://
 *         - 有上下文https:// → 补全为https://
 *         - 无上下文 → 默认https://
 *         - Visit example.com or example.org → 两个都补全
 * 阶段4：文本重组 → 将原文本链接位置替换为占位符{{LINK_N}}
 * 阶段5：严格分词 → 对非链接文本进行标准分词（中英分离、数字分离、标点独立）
 * 阶段6：输出排序 → 链接片段（按出现顺序）→ 补全链接 → 分词结果
 *
 * 严格分词定义：
 * - 中文字符：逐字分格（非整句）
 * - 英文字母：按单词分格
 * - 数字：连续数字作为一格
 * - 标点：每个独立成格
 * - 空格：全部去除
 *
 * 设置项：settings.aiApiKey, settings.aiModel, settings.aiDefaultProtocol
 */
function aiAnalysis(text, config) {
  // 实现逻辑...
}
```

### 1.7 整句分析

```javascript
/**
 * 整句分析模式
 *
 * 处理逻辑：
 * 1. 句子边界识别：/[.!?。！？]+[\s"']*/g 或换行符
 * 2. 去除所有空格：/\s+/g 替换为空
 * 3. 中间不再分词：每个整句作为独立单元
 *
 * 与代码分析中整句的区别：
 * - 此模式纯粹按标点分句，无代码语义识别
 * - 代码分析中的整句是语法结构单元
 */
function sentenceAnalysis(text) {
    // 实现逻辑...
}
```

### 1.8 去除符号

```javascript
/**
 * 去除符号模式
 *
 * 处理流程：
 * 1. 符号分格：/[^\w\s\u4e00-\u9fa5]/g 识别所有符号
 * 2. 去除符号：将符号从文本中删除
 * 3. 整句分离：按句子边界分割
 * 4. 空格换行分离：/\s+/ 作为分隔
 * 5. 中英数字分离：
 *    - 中文：[\u4e00-\u9fa5]+
 *    - 英文：[a-zA-Z]+
 *    - 数字：\d+
 *
 * 结果：仅保留中英文字符和数字，无任何符号
 */
function removeSymbolsMode(text) {
  // 实现逻辑...
}
```

### 1.9 随机分词

```javascript
/**
 * 随机分词模式
 *
 * 处理逻辑：
 * 1. 去除所有空白字符
 * 2. 从头到尾遍历文本
 * 3. 每次随机取长度：random(settings.randomMinLen, settings.randomMaxLen)
 * 4. 剩余字符不足时取实际剩余长度
 * 5. 生成结果数组
 *
 * 刷新生成机制：
 * - 按钮位置：结果面板右上角
 * - 点击行为：重新执行随机算法，生成新结果
 * - 历史记录：不保存到历史栈，不可回溯
 * - 动画效果：结果逐字符渐显（可选）
 *
 * 随机算法：
 * function randomSplit(text, min, max) {
 *     const result = [];
 *     let pos = 0;
 *     while (pos < text.length) {
 *         const remaining = text.length - pos;
 *         const actualMax = Math.min(max, remaining);
 *         const len = Math.floor(Math.random() * (actualMax - min + 1)) + min;
 *         result.push(text.slice(pos, pos + len));
 *         pos += len;
 *     }
 *     return result;
 * }
 *
 * 设置项：settings.randomMinLen（默认1），settings.randomMaxLen（默认10）
 */
function randomSplitMode(text, minLen, maxLen) {
  // 实现逻辑...
}
```

---

## 二、组合选项（可叠加）

```javascript
/**
 * 组合选项处理规则
 *
 * 核心原则：直接处理原始文本，不对基础模式结果二次处理
 * 执行方式：按一次执行一次，从左到右依次应用
 * 历史记录：每次执行结果保存到历史栈（随机分词除外）
 *
 * UI布局：网格布局，每行2个按钮
 * 第1行：[符号分词]    [空格,换行分词]
 * 第2行：[中英分词]    [大写分词]
 * 第3行：[命名分词]    [数字分词]
 * 第4行：[去除空格]    [去除符号]
 * 第5行：[去除中文]    [去除英文]
 */

const comboOptions = {
  /**
   * 符号分词
   * 规则：符号放在上词词尾，成对符号的前半部分除外
   * 成对符号：(), [], {}, "", '', ``, <>
   * 示例："Hello, world!" → ["Hello,", "world!"]
   * 例外："(test)" → ["(", "test", ")"]（括号不归属）
   */
  symbolSplit: function (text) {
    /* ... */
  },

  /**
   * 空格换行分词
   * 规则：/\s+/ 作为分隔，归属前一词词尾
   * 示例："Hello world" → ["Hello ", "world"]（空格归属Hello）
   * 行尾换行符同理归属
   */
  whitespaceSplit: function (text) {
    /* ... */
  },

  /**
   * 中英分词
   * 规则：中文[\u4e00-\u9fa5]与非中文字符之间强制分格
   * 示例："Hello世界" → ["Hello", "世界"]
   */
  cnEnSplit: function (text) {
    /* ... */
  },

  /**
   * 大写分词
   * 规则：将每个大写字母分成独立单元
   * 与命名分词区别：命名分词按驼峰分割，大写分词逐字母分割
   * 示例："DarkSOUL" → ["D", "a", "r", "k", "S", "O", "U", "L"]
   * 依赖：建议先执行中英分词
   */
  uppercaseSplit: function (text) {
    /* ... */
  },

  /**
   * 命名分词
   * 规则：识别各类命名法并分割
   * - 驼峰：DarkSoul → Dark, Soul
   * - 蛇形：dark_soul → dark, soul（默认去除下划线）
   * - 短横线：dark-soul → dark, soul（默认去除短横线）
   * - 连续大写：DARKSOUL → DARKSOUL（不拆）
   * - 混合：XMLHttpRequest → XMLHttp, Request
   * 设置：settings.namingRemoveSymbol（默认true）
   */
  namingSplit: function (text, removeSymbol) {
    /* ... */
  },

  /**
   * 数字分词
   * 规则：/\d+/ 连续数字作为独立单元，与非数字分离
   * 示例："test123abc" → ["test", "123", "abc"]
   */
  numberSplit: function (text) {
    /* ... */
  },

  /**
   * 去除空格
   * 规则：/\s+/g 全部删除
   */
  removeSpace: function (text) {
    /* ... */
  },

  /**
   * 去除符号
   * 规则：/[^\w\s\u4e00-\u9fa5]/g 全部删除
   */
  removeSymbol: function (text) {
    /* ... */
  },

  /**
   * 去除中文
   * 规则：/[\u4e00-\u9fa5]/g 全部删除
   */
  removeChinese: function (text) {
    /* ... */
  },

  /**
   * 去除英文
   * 规则：/[a-zA-Z]/g 全部删除
   */
  removeEnglish: function (text) {
    /* ... */
  },
};
```

---

## 三、互斥组与依赖关系

```javascript
/**
 * 互斥组定义 - 同一组内只能有一个生效
 */
const mutexGroups = {
  groupA: ["chineseAnalysis", "englishAnalysis"], // 中文分析与英文分析
  groupB: ["sentenceAnalysis", "charBreakLine"], // 整句分析与字符断行
  groupC: ["smartAnalysis", "codeAnalysis"], // 智能分析与代码分析
};

/**
 * 依赖关系定义 - 主选项依赖依赖选项
 */
const dependencies = {
  // D1: 命名分词默认去除符号，但可配置
  namingSplit: {
    requires: [],
    suggests: ["removeSymbol"],
    config: "namingRemoveSymbol",
  },

  // D2: 大写分词建议先中英分离
  uppercaseSplit: { requires: [], suggests: ["cnEnSplit"] },

  // D3: 符号分词与去除符号互斥时，以去除符号为准
  symbolSplit: { mutexWith: ["removeSymbol"], priority: "removeSymbol" },

  // D4: AI分析内部依赖严格分词，对外无依赖
  aiAnalysis: { internal: ["strictSplit"] },
};

/**
 * 特殊组合处理规则
 */
const specialCombos = {
  // 去除符号 + 符号分词 = 仅执行去除符号
  "removeSymbol+symbolSplit": (text) => comboOptions.removeSymbol(text),

  // 去除中文 + 去除英文 + 去除数字 = 仅保留符号和空格
  "removeChinese+removeEnglish+numberSplit": (text) => {
    return text.replace(/[\u4e00-\u9fa5a-zA-Z0-9]/g, "");
  },

  // 去除空格 + 去除符号 = 先去除符号，再去除空格
  "removeSpace+removeSymbol": (text) => {
    return comboOptions.removeSpace(comboOptions.removeSymbol(text));
  },
};
```

---

## 四、历史栈与重复返回

```javascript
/**
 * 历史栈管理
 *
 * 容量限制：动态计算，最大6次
 * 计算公式：
 * function calculateMaxReturns(textLength) {
 *     if (textLength < 1000) return 6;
 *     if (textLength < 5000) return 5;
 *     if (textLength < 10000) return 4;
 *     if (textLength < 20000) return 3;
 *     if (textLength < 50000) return 2;
 *     return 1;
 * }
 *
 * 内存保护：
 * - 单条历史记录上限：1MB
 * - 超出时自动截断，保留分词结果索引而非完整文本副本
 *
 * 随机分词例外：
 * - 结果不保存到历史栈
 * - 刷新生成按钮直接重新执行
 * - 无回溯能力
 *
 * 持久化：settings.historyMaxSize（默认6，范围1-10）
 */
const historyManager = {
  stack: [],
  maxSize: 6,

  push: function (result, textLength) {
    this.maxSize = calculateMaxReturns(textLength);
    // 实现逻辑...
  },

  pop: function () {
    // 返回上一次结果，最多回溯maxSize次
  },
};
```

---

## 五、设置界面规范

```javascript
/**
 * 设置界面布局 - 全局持久化（chrome.storage.local）
 *
 * ┌─────────────────────────────────────┐
 * │  设置                    [X]        │
 * ├─────────────────────────────────────┤
 * │  [中文分词]                         │
 * │    ☑ 启用词典                       │
 * │    ☑ 启用算法                       │
 * │                                     │
 * │  [AI分析]                           │
 * │    API Key: [________________]      │
 * │    模型选择: [GPT-4 ▼]              │
 * │    默认协议: [https:// ▼]           │
 * │                                     │
 * │  [字符断行]                         │
 * │    行字符数: [100]                  │
 * │                                     │
 * │  [随机分词]                         │
 * │    最小长度: [1]                    │
 * │    最大长度: [10]                   │
 * │                                     │
 * │  [命名分词]                         │
 * │    ☑ 去除符号（默认启用）            │
 * │                                     │
 * │  [高级]                             │
 * │    历史栈上限: [6]                  │
 * └─────────────────────────────────────┘
 */

const settingsSchema = {
  // 中文分词
  cnUseDict: { type: "boolean", default: true, key: "settings.cnUseDict" },
  cnUseAlgo: { type: "boolean", default: true, key: "settings.cnUseAlgo" },

  // AI分析
  aiApiKey: { type: "string", default: "", key: "settings.aiApiKey" },
  aiModel: {
    type: "enum",
    values: ["GPT-4", "Claude", "Gemini"],
    default: "GPT-4",
    key: "settings.aiModel",
  },
  aiDefaultProtocol: {
    type: "enum",
    values: ["https://", "http://"],
    default: "https://",
    key: "settings.aiDefaultProtocol",
  },

  // 字符断行
  charBreakLength: {
    type: "number",
    min: 10,
    max: 500,
    default: 100,
    key: "settings.charBreakLength",
  },

  // 随机分词
  randomMinLen: {
    type: "number",
    min: 1,
    max: 5,
    default: 1,
    key: "settings.randomMinLen",
  },
  randomMaxLen: {
    type: "number",
    min: 5,
    max: 20,
    default: 10,
    key: "settings.randomMaxLen",
  },

  // 命名分词
  namingRemoveSymbol: {
    type: "boolean",
    default: true,
    key: "settings.namingRemoveSymbol",
  },

  // 高级
  historyMaxSize: {
    type: "number",
    min: 1,
    max: 10,
    default: 6,
    key: "settings.historyMaxSize",
  },
};
```

---

## 六、错误处理规范

```javascript
/**
 * 错误码定义与处理策略
 */
const errorHandlers = {
  // E001: 文本为空
  E001: {
    condition: (text) => !text || text.length === 0,
    action: () => [],
    log: "Warning: Empty text input",
  },

  // E002: 正则表达式错误
  E002: {
    condition: (e) =>
      e instanceof SyntaxError &&
      e.message.includes("Invalid regular expression"),
    action: (fn, fallbackRegex) => {
      console.warn("Regex error, using fallback:", fallbackRegex);
      return fn(fallbackRegex);
    },
    log: "Error: Invalid regex pattern, fallback used",
  },

  // E003: 缩进解析异常（Python模式）
  E003: {
    condition: (e) => e.message === "IndentationError",
    action: (text) => sentenceAnalysis(text), // 退化为整句分析
    log: "Warning: Indent parse failed, fallback to sentence mode",
  },

  // E004: 符号匹配异常（C++模式）
  E004: {
    condition: (e) => e.message === "UnmatchedBrace",
    action: (line) => [line.trim()], // 跳过异常行，作为整句
    log: "Warning: Unmatched brace in line, treated as sentence",
  },

  // E005: 内存超限
  E005: {
    condition: (text) => text.length > 1000000, // 1MB文本
    action: (text, processor) => {
      // 分批处理，返回部分结果
      const chunks = text.match(/.{1,100000}/g);
      return chunks.flatMap((chunk) => processor(chunk));
    },
    log: "Warning: Large text detected, processing in chunks",
  },
};
```

---

## 七、测试用例

```javascript
/**
 * 核心功能测试用例
 */

// 测试1：Python代码分析
const pythonInput = `def hello():
    print("Hello")
    if True:
        print("World")

class Test:
    def __init__(self):
        pass`;

const pythonExpected = [
  "def hello():",
  'print("Hello")',
  'print("World")',
  "class Test:",
  "def __init__(self):",
  "pass",
];

// 测试2：C++代码分析
const cppInput = `#include <iostream>
int main() {
    std::cout << "Hello";
    if (true) {
        std::cout << "World";
    }
}`;

const cppExpected = [
  "#include <iostream>",
  "int main() {",
  'std::cout << "Hello";',
  'std::cout << "World";',
  "}",
];

// 测试3：命名法处理
console.log(englishAnalysis("DarkSOUL")); // ["Dark", "SOUL"]
console.log(englishAnalysis("HTTPSConnection")); // ["HTTPSConnection"]
console.log(englishAnalysis("XMLHttpRequest")); // ["XMLHttp", "Request"]

// 测试4：AI链接补全
console.log(aiAnalysis("Visit example.com or example.org"));
// 输出：["https://example.com ", "https://example.org ", "Visit", "or"]

// 测试5：特殊组合
console.log(
  comboOptions.removeSymbol(comboOptions.symbolSplit("Hello, world!")),
);
// 去除符号优先，结果：["Helloworld"]（符号被去除，符号分词不执行）
```

---

## 八、实现优先级

```javascript
/**
 * 第一阶段：核心基础（必须）
 * - 代码类型检测算法
 * - C++成对符号匹配（最近}匹配）
 * - Python缩进栈算法
 * - 整句识别规则
 * - 智能分析基础功能
 */

/**
 * 第二阶段：功能完善（重要）
 * - AI分析链接处理流水线（含补全逻辑）
 * - 中文分析词典/算法开关
 * - 组合选项互斥组检查
 * - 组合选项依赖解析
 * - 历史栈动态限制
 */

/**
 * 第三阶段：体验优化（增强）
 * - 随机分词刷新生成按钮
 * - 设置界面完整实现
 * - 全局持久化配置
 * - 错误处理完善
 * - 性能优化（大文本分块）
 */

/**
 * 第四阶段：细节打磨（可选）
 * - 随机分词渐显动画
 * - 组合选项视觉反馈（互斥置灰）
 * - 历史栈可视化
 * - 分词结果高亮映射
 */
```

---

## 九、关键边界条件

```javascript
/**
 * 边界条件处理规范
 */

// 1. 空文本
handleEmpty: (text) => (text ? process(text) : []);

// 2. 仅空白字符
handleWhitespaceOnly: (text) => (/^\s*$/.test(text) ? [] : process(text));

// 3. 混合编码
handleEncoding: (text) => {
  // 使用Array.from确保Unicode安全
  const chars = Array.from(text);
  return process(chars);
};

// 4. 极端缩进（Python）
handleExtremeIndent: (lines) => {
  // 缩进超过100层视为异常，退化为行分析
  if (indentStack.length > 100) return lineBasedAnalysis(lines);
};

// 5. 嵌套符号过深（C++）
handleDeepNesting: (text) => {
  // 嵌套超过50层视为异常，按行分割
  if (nestingLevel > 50) return text.split("\n").map((l) => l.trim());
};

// 6. 超大文本
handleLargeText: (text, maxChunk = 100000) => {
  if (text.length <= maxChunk) return process(text);
  // 分块处理，在句子边界切割
  return chunkProcess(text, maxChunk);
};
```

---

**文档状态**：完整覆盖所有需求，可直接用于开发实施。
