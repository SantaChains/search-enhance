# 分词系统升级实现方案

## 一、项目现状分析

### 1.1 现有架构梳理

项目采用Chrome扩展Manifest V3架构，核心模块分布如下：

| 模块 | 路径 | 功能 | 状态 |
|------|------|------|------|
| 文本处理 | `src/utils/textProcessor.js` | 基础分词、链接提取、多格式分析 | 已实现 |
| AI适配器 | `src/utils/aiAdapter.js` | 多服务商适配、流式输出 | 已实现 |
| 存储管理 | `src/utils/storage.js` | 配置持久化、历史记录 | 已实现 |
| 设置界面 | `src/settings/main.js` | 搜索引擎配置 | 部分实现 |
| 弹窗界面 | `src/popup/main.js` | 主交互界面 | 已实现 |

### 1.2 现有能力与差距

**已支持**：
- 智能分析（基础版）
- 中文分词（词典+算法）
- 英文命名法分割
- 链接提取与补全
- 多搜索引擎配置
- 历史记录管理

**待实现**：
- Python缩进栈算法
- C++成对符号匹配
- 字符断行模式
- 组合选项互斥组
- 组合选项依赖关系
- 历史栈动态限制
- 错误处理完善
- 设置界面扩展

---

## 二、代码分析模块实现方案

### 2.1 代码类型检测器

**实现位置**：`src/utils/textProcessor.js` 新增 `detectCodeMode(text)` 函数

```javascript
/**
 * 代码类型检测器
 * 
 * 检测逻辑：
 * 1. 检测文本中是否包含 { 或 } 符号 → C++模式
 * 2. 检测是否有行以 : 结尾（Python缩进标记）→ Python模式
 * 3. 否则 → 整句分析模式
 * 
 * 与现有代码集成：
 * 在 processMultiFormat() 中调用，或新增专用入口函数
 * 
 * @param {string} text 输入文本
 * @returns {string} 模式标识：'cpp_brace' | 'python_indent' | 'line_based'
 */
export function detectCodeMode(text) {
    // 优先检测C++花括号
    if (text.includes('{') || text.includes('}')) {
        return 'cpp_brace';
    }
    
    // 检测Python缩进标记（行尾冒号）
    const lines = text.split(/\r?\n/);
    const hasPythonIndent = lines.some(line => line.trim().endsWith(':'));
    if (hasPythonIndent) {
        return 'python_indent';
    }
    
    // 退化到整句分析
    return 'line_based';
}
```

### 2.2 C++代码分析 - 成对符号匹配

**实现位置**：`src/utils/textProcessor.js` 新增 `analyzeCpp(text)` 函数

```javascript
/**
 * C++代码分析器 - 成对符号匹配算法
 * 
 * 核心原则：不调用splitText，防止函数体不完整
 * 
 * 符号对定义：
 * - 主要：{ }（代码块）
 * - 次要：( )、[ ]、" "、' '、` `（辅助识别）
 * 
 * 处理步骤：
 * 1. 按行分离原始文本
 * 2. 建立{位置索引：braceStack = []
 * 3. 扫描每行，记录{和}的位置
 * 4. 对于每个{，找到最近的}（不论是否成对）
 * 5. 将{...}内容组合成新行
 * 6. 不含{}的行作为整句输出
 * 
 * 整句识别规则：
 * - #include <...> 整行输出
 * - #define xxx 整行输出
 * - 函数声明整行输出
 * 
 * @param {string} text C++代码文本
 * @returns {string[]} 分析结果数组
 */
export function analyzeCpp(text) {
    const lines = text.split(/\r?\n/);
    const result = [];
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const trimmed = line.trim();
        
        // 整句识别：#include、#define、前置声明
        if (trimmed.startsWith('#include') || 
            trimmed.startsWith('#define') ||
            /^(int|void|bool|char|float|double|class|struct)\s+\w+\s*\(/.test(trimmed)) {
            result.push(trimmed);
            continue;
        }
        
        // 函数体识别：{...}组合
        if (trimmed.includes('{')) {
            let braceCount = 0;
            let codeBlock = '';
            
            for (let j = i; j < lines.length; j++) {
                const currentLine = lines[j];
                codeBlock += currentLine + '\n';
                
                // 统计花括号
                for (const char of currentLine) {
                    if (char === '{') braceCount++;
                    if (char === '}') braceCount--;
                }
                
                // 找到闭合或异常结束
                if (braceCount <= 0) {
                    result.push(codeBlock.trim());
                    i = j; // 跳到闭合 brace 的下一行
                    break;
                }
            }
        } else if (!trimmed.endsWith('}') && trimmed !== '') {
            // 不含{的行，按整句处理
            result.push(trimmed);
        }
    }
    
    return result.filter(line => line.length > 0);
}
```

### 2.3 Python代码分析 - 缩进栈算法

**实现位置**：`src/utils/textProcessor.js` 新增 `analyzePython(text)` 函数

```javascript
/**
 * Python代码分析器 - 缩进栈算法
 * 
 * 核心原则：按缩进层级组织代码块，保持函数体完整性
 * 
 * 数据结构：
 * - indentStack: 缩进栈，记录每层缩进空格数，初始 [0]
 * - 代码块栈：blockStack，对应栈层的代码内容
 * 
 * 行分类规则：
 * - 空行 → 跳过（不输出）
 * - 缩进增加（indent > stackTop）→ 推入新栈层，开启代码块
 * - 缩进不变（indent === stackTop）→ 延续当前代码块
 * - 缩进减少（indent < stackTop）→ 弹出栈层，归属于父级块
 * 
 * 函数体识别：
 * - 包含 : 的行作为块头
 * - 后续同栈层行为函数体组成部分
 * 
 * @param {string} text Python代码文本
 * @returns {string[]} 分析结果数组
 */
export function analyzePython(text) {
    const lines = text.split(/\r?\n/);
    const result = [];
    
    // 缩进栈：[缩进量]
    const indentStack = [0];
    // 代码块栈：对应栈层的代码内容
    const blockStack = [[]];
    
    for (const line of lines) {
        if (!line.trim()) continue; // 跳过空行
        
        // 计算当前行缩进（空格数）
        const indent = line.search(/\S/);
        const trimmed = line.trim();
        
        // 缩进增加：推入新层
        if (indent > indentStack[indentStack.length - 1]) {
            indentStack.push(indent);
            blockStack.push([]);
        }
        // 缩进减少：弹出栈层
        else if (indent < indentStack[indentStack.length - 1]) {
            while (indentStack.length > 1 && 
                   indent < indentStack[indentStack.length - 1]) {
                indentStack.pop();
                blockStack.pop();
            }
        }
        
        // 当前栈层的代码块
        const currentBlock = blockStack[blockStack.length - 1];
        
        // 函数头识别
        if (trimmed.endsWith(':')) {
            currentBlock.push(trimmed);
        } else {
            // 普通代码行，保持缩进后输出
            const spaces = ' '.repeat(indent);
            currentBlock.push(spaces + trimmed);
        }
        
        // 检查是否需要弹出（下一行缩进更小）
        // 在下一轮迭代中处理
    }
    
    // 收集所有代码块
    for (const block of blockStack) {
        result.push(...block);
    }
    
    return result;
}
```

---

## 三、基础分析模式实现方案

### 3.1 字符断行模式（原混沌文本）

**实现位置**：`src/utils/textProcessor.js` 新增 `charBreakLine(text, lineLength)` 函数

```javascript
/**
 * 字符断行模式
 * 
 * 处理逻辑：
 * 1. 去除所有现有换行符
 * 2. 使用Array.from确保Unicode字符正确计数
 * 3. 按设定值严格切割，不考虑语义边界
 * 
 * 编码安全：
 * - Array.from(string) 正确处理UTF-16代理对
 * - 避免在emoji中间切断
 * 
 * 设置集成：
 * - 使用 chrome.storage.local 读取 settings.charBreakLength
 * - 默认值：100，范围：10-500
 * 
 * @param {string} text 输入文本
 * @param {number} lineLength 每行字符数
 * @returns {string[]} 断行结果数组
 */
export function charBreakLine(text, lineLength = 100) {
    // 使用Array.from确保Unicode安全
    const chars = Array.from(text);
    const result = [];
    
    for (let i = 0; i < chars.length; i += lineLength) {
        result.push(chars.slice(i, i + lineLength).join(''));
    }
    
    return result;
}
```

### 3.2 整句分析模式

**实现位置**：`src/utils/textProcessor.js` 新增 `sentenceAnalysis(text)` 函数

```javascript
/**
 * 整句分析模式
 * 
 * 处理逻辑：
 * 1. 句子边界识别：/[.!?。！？]+[\s"']*/g 或换行符
 * 2. 去除所有空格：/\s+/g 替换为空
 * 3. 中间不再分词：每个整句作为独立单元
 * 
 * 与代码分析中整句的区别：
 * - 此模式纯粹按标点分句，无代码语义识别
 * - 代码分析中的整句是语法结构单元
 * 
 * @param {string} text 输入文本
 * @returns {string[]} 整句数组
 */
export function sentenceAnalysis(text) {
    // 句子边界识别（中英文标点）
    const sentenceRegex = /[^.!?。！？]+[.!?。！？]?|[。！？]/g;
    const sentences = text.match(sentenceRegex) || [];
    
    // 去除空格，保持整句完整
    return sentences
        .map(s => s.replace(/\s+/g, '').trim())
        .filter(s => s.length > 0);
}
```

### 3.3 去除符号模式

**实现位置**：`src/utils/textProcessor.js` 新增 `removeSymbolsMode(text)` 函数

```javascript
/**
 * 去除符号模式
 * 
 * 处理流程：
 * 1. 符号分格：[^\w\s\u4e00-\u9fa5] 识别所有符号
 * 2. 去除符号：将符号从文本中删除
 * 3. 整句分离：按句子边界分割
 * 4. 空格换行分离：/\s+/ 作为分隔
 * 5. 中英数字分离：
 *    - 中文：[\u4e00-\u9fa5]+
 *    - 英文：[a-zA-Z]+
 *    - 数字：\d+
 * 
 * 结果：仅保留中英文字符和数字，无任何符号
 * 
 * @param {string} text 输入文本
 * @returns {string[]} 处理结果数组
 */
export function removeSymbolsMode(text) {
    // 步骤1-2：去除符号
    const noSymbols = text.replace(/[^\w\s\u4e00-\u9fa5]/g, '');
    
    // 步骤3-5：分离处理
    return splitText(noSymbols, ['chinese-sentence', 'english-sentence', 'whitespace']);
}
```

---

## 四、组合选项实现方案

### 4.1 组合选项处理器架构

**实现位置**：`src/utils/textProcessor.js` 新增 `ComboOptionProcessor` 类

```javascript
/**
 * 组合选项处理器
 * 
 * 核心原则：
 * - 直接处理原始文本，不对基础模式结果二次处理
 * - 按一次执行一次，从左到右依次应用
 * - 随机分词除外：不保存到历史栈
 * 
 * 互斥组定义：
 * - groupA: 中文分析 ↔ 英文分析
 * - groupB: 整句分析 ↔ 字符断行
 * - groupC: 智能分析 ↔ 代码分析
 * 
 * 依赖关系：
 * - D1: 命名分词默认去除符号（可配置）
 * - D2: 大写分词建议先中英分离
 * - D3: 符号分词与去除符号互斥时，以去除符号为准
 * - D4: AI分析内部依赖严格分词
 */
class ComboOptionProcessor {
    constructor() {
        // 组合选项注册表
        this.options = {
            symbolSplit: this.symbolSplit.bind(this),
            whitespaceSplit: this.whitespaceSplit.bind(this),
            cnEnSplit: this.cnEnSplit.bind(this),
            uppercaseSplit: this.uppercaseSplit.bind(this),
            namingSplit: this.namingSplit.bind(this),
            numberSplit: this.numberSplit.bind(this),
            removeSpace: this.removeSpace.bind(this),
            removeSymbol: this.removeSymbol.bind(this),
            removeChinese: this.removeChinese.bind(this),
            removeEnglish: this.removeEnglish.bind(this),
        };
        
        // 互斥组
        this.mutexGroups = {
            groupA: ['chineseAnalysis', 'englishAnalysis'],
            groupB: ['sentenceAnalysis', 'charBreakLine'],
            groupC: ['smartAnalysis', 'codeAnalysis'],
        };
        
        // 依赖关系
        this.dependencies = {
            namingSplit: { suggests: ['removeSymbol'], config: 'namingRemoveSymbol' },
            uppercaseSplit: { suggests: ['cnEnSplit'] },
            symbolSplit: { mutexWith: ['removeSymbol'], priority: 'removeSymbol' },
        };
    }
    
    /**
     * 执行组合选项
     * @param {string} text 原始文本
     * @param {string[]} selectedOptions 选中的选项列表
     * @param {object} settings 用户配置
     * @returns {string[]} 处理结果
     */
    execute(text, selectedOptions, settings = {}) {
        let result = text;
        
        for (const option of selectedOptions) {
            const handler = this.options[option];
            if (handler) {
                result = handler(result, settings);
            }
        }
        
        return Array.isArray(result) ? result : [result];
    }
    
    // === 组合选项实现 ===
    
    /**
     * 符号分词
     * 规则：符号放在上词词尾，成对符号的前半部分除外
     * 成对符号：(), [], {}, "", '', ``, <>
     */
    symbolSplit(text) {
        return text.split(/([^\w\s])/);
    }
    
    /**
     * 空格换行分词
     * 规则：/\s+/ 作为分隔，归属前一词词尾
     */
    whitespaceSplit(text) {
        return text.split(/(\s+)/);
    }
    
    /**
     * 中英分词
     * 规则：中文[\u4e00-\u9fa5]与非中文字符之间强制分格
     */
    cnEnSplit(text) {
        return text.split(/(?=[\u4e00-\u9fa5])|(?=[a-zA-Z])/);
    }
    
    /**
     * 大写分词
     * 规则：将每个大写字母分成独立单元
     * 与命名分词区别：命名分词按驼峰分割，大写分词逐字母分割
     * 示例："DarkSOUL" → ["D", "a", "r", "k", "S", "O", "U", "L"]
     */
    uppercaseSplit(text) {
        return text.split(/(?=[A-Z])/);
    }
    
    /**
     * 命名分词
     * 规则：识别各类命名法并分割
     * - 驼峰：DarkSoul → Dark, Soul
     * - 蛇形：dark_soul → dark, soul
     * - 短横线：dark-soul → dark, soul
     * - 连续大写：DARKSOUL → DARKSOUL（不拆）
     * - 混合：XMLHttpRequest → XMLHttp, Request
     */
    namingSplit(text, settings = {}) {
        const removeSymbol = settings.namingRemoveSymbol !== false;
        
        // 驼峰分割
        let result = text.split(/(?=[A-Z])/);
        
        // 蛇形/短横线分割
        result = result.flatMap(s => {
            if (removeSymbol) {
                return s.split(/[-_]/).filter(Boolean);
            }
            return [s];
        });
        
        return result;
    }
    
    /**
     * 数字分词
     * 规则：/\d+/ 连续数字作为独立单元，与非数字分离
     */
    numberSplit(text) {
        return text.split(/(\d+)/);
    }
    
    /**
     * 去除空格
     */
    removeSpace(text) {
        return text.replace(/\s+/g, '');
    }
    
    /**
     * 去除符号
     */
    removeSymbol(text) {
        return text.replace(/[^\w\s\u4e00-\u9fa5]/g, '');
    }
    
    /**
     * 去除中文
     */
    removeChinese(text) {
        return text.replace(/[\u4e00-\u9fa5]/g, '');
    }
    
    /**
     * 去除英文
     */
    removeEnglish(text) {
        return text.replace(/[a-zA-Z]/g, '');
    }
}
```

---

## 五、历史栈与重复返回实现

**实现位置**：`src/utils/textProcessor.js` 新增 `HistoryManager` 类

```javascript
/**
 * 历史栈管理器
 * 
 * 容量限制：动态计算，最大6次
 * 
 * 计算公式：
 * - 文本长度 < 1000 → 6次
 * - 文本长度 < 5000 → 5次
 * - 文本长度 < 10000 → 4次
 * - 文本长度 < 20000 → 3次
 * - 文本长度 < 50000 → 2次
 * - 文本长度 ≥ 50000 → 1次
 * 
 * 内存保护：
 * - 单条历史记录上限：1MB
 * - 超出时自动截断
 * 
 * 随机分词例外：
 * - 结果不保存到历史栈
 * - 刷新生成按钮直接重新执行
 * - 无回溯能力
 */
class HistoryManager {
    constructor() {
        this.stack = [];
        this.maxSize = 6;
    }
    
    /**
     * 动态计算最大返回次数
     * @param {number} textLength 文本长度
     * @returns {number} 最大返回次数
     */
    calculateMaxReturns(textLength) {
        if (textLength < 1000) return 6;
        if (textLength < 5000) return 5;
        if (textLength < 10000) return 4;
        if (textLength < 20000) return 3;
        if (textLength < 50000) return 2;
        return 1;
    }
    
    /**
     * 推入历史记录
     * @param {string[]} result 分词结果
     * @param {number} textLength 原始文本长度
     */
    push(result, textLength) {
        this.maxSize = this.calculateMaxReturns(textLength);
        
        // 内存保护：检查单条记录大小
        const resultStr = JSON.stringify(result);
        if (resultStr.length > 1024 * 1024) {
            // 超出1MB，截断处理
            console.warn('[HistoryManager] 历史记录超出1MB，自动截断');
        }
        
        this.stack.unshift({
            result,
            timestamp: Date.now(),
            textLength
        });
        
        // 限制栈大小
        if (this.stack.length > this.maxSize) {
            this.stack.length = this.maxSize;
        }
    }
    
    /**
     * 弹出历史记录
     * @returns {string[]|null} 上一次结果，null表示无历史
     */
    pop() {
        if (this.stack.length === 0) return null;
        return this.stack.shift()?.result || null;
    }
    
    /**
     * 清除历史
     */
    clear() {
        this.stack = [];
    }
}
```

---

## 六、设置界面扩展方案

### 6.1 新增设置项

**修改位置**：`src/utils/storage.js` - `DEFAULTS` 对象

```javascript
// === 新增分词设置 ===

export const DEFAULTS = {
    // ... 现有设置 ...
    
    // 分词设置
    tokenizerSettings: {
        // 中文分词
        cnUseDict: true,
        cnUseAlgo: true,
        
        // AI分析
        aiApiKey: '',
        aiModel: 'gpt-4o-mini',
        aiDefaultProtocol: 'https://',
        
        // 字符断行
        charBreakLength: 100,
        
        // 随机分词
        randomMinLen: 1,
        randomMaxLen: 10,
        
        // 命名分词
        namingRemoveSymbol: true,
        
        // 历史栈
        historyMaxSize: 6,
    },
};
```

### 6.2 设置界面HTML扩展

**修改位置**：`src/settings/index.html`

```html
<!-- 新增分词设置面板 -->
<div class="settings-section" id="tokenizer-settings">
    <h3>分词设置</h3>
    
    <!-- 中文分词 -->
    <div class="setting-group">
        <label>中文分词</label>
        <div class="checkbox-group">
            <label>
                <input type="checkbox" id="cn-use-dict" checked>
                启用词典
            </label>
            <label>
                <input type="checkbox" id="cn-use-algo" checked>
                启用算法
            </label>
        </div>
    </div>
    
    <!-- AI分析 -->
    <div class="setting-group">
        <label>AI分析</label>
        <input type="password" id="ai-api-key" placeholder="API Key">
        <select id="ai-model">
            <option value="gpt-4o-mini">GPT-4o-mini</option>
            <option value="gpt-4o">GPT-4o</option>
            <option value="claude-3-5-sonnet">Claude 3.5 Sonnet</option>
        </select>
        <select id="ai-protocol">
            <option value="https://">默认 https://</option>
            <option value="http://">默认 http://</option>
        </select>
    </div>
    
    <!-- 字符断行 -->
    <div class="setting-group">
        <label>字符断行</label>
        <input type="number" id="char-break-length" min="10" max="500" value="100">
        <span>每行字符数</span>
    </div>
    
    <!-- 随机分词 -->
    <div class="setting-group">
        <label>随机分词</label>
        <div class="range-group">
            <span>最小长度:</span>
            <input type="number" id="random-min-len" min="1" max="5" value="1">
            <span>最大长度:</span>
            <input type="number" id="random-max-len" min="5" max="20" value="10">
        </div>
    </div>
    
    <!-- 命名分词 -->
    <div class="setting-group">
        <label>命名分词</label>
        <label>
            <input type="checkbox" id="naming-remove-symbol" checked>
            去除符号（默认启用）
        </label>
    </div>
    
    <!-- 历史栈 -->
    <div class="setting-group">
        <label>历史栈上限</label>
        <input type="number" id="history-max-size" min="1" max="10" value="6">
    </div>
</div>
```

---

## 七、错误处理实现方案

**实现位置**：`src/utils/textProcessor.js` 新增错误处理器

```javascript
/**
 * 错误处理器
 */
const errorHandlers = {
    /**
     * E001: 文本为空
     */
    E001: {
        condition: (text) => !text || text.length === 0,
        action: () => [],
        log: 'Warning: Empty text input',
    },
    
    /**
     * E002: 正则表达式错误
     */
    E002: {
        condition: (e) => e instanceof SyntaxError && e.message.includes('Invalid regular expression'),
        action: (fn, fallbackRegex) => {
            console.warn('Regex error, using fallback:', fallbackRegex);
            return fn(fallbackRegex);
        },
        log: 'Error: Invalid regex pattern, fallback used',
    },
    
    /**
     * E003: 缩进解析异常（Python模式）
     */
    E003: {
        condition: (e) => e.message === 'IndentationError',
        action: (text) => sentenceAnalysis(text),
        log: 'Warning: Indent parse failed, fallback to sentence mode',
    },
    
    /**
     * E004: 符号匹配异常（C++模式）
     */
    E004: {
        condition: (e) => e.message === 'UnmatchedBrace',
        action: (line) => [line.trim()],
        log: 'Warning: Unmatched brace in line, treated as sentence',
    },
    
    /**
     * E005: 内存超限
     */
    E005: {
        condition: (text) => text.length > 1000000,
        action: (text, processor) => {
            const chunks = text.match(/.{1,100000}/g);
            return chunks.flatMap(chunk => processor(chunk));
        },
        log: 'Warning: Large text detected, processing in chunks',
    },
};

/**
 * 安全执行处理函数
 * @param {Function} processor 处理函数
 * @param {string} text 输入文本
 * @param {...any} args 处理函数参数
 * @returns {any} 处理结果
 */
function safeExecute(processor, text, ...args) {
    try {
        return processor(text, ...args);
    } catch (error) {
        // 查找对应的错误处理器
        for (const [code, handler] of Object.entries(errorHandlers)) {
            if (handler.condition(error)) {
                console.error(`[ErrorHandler] ${code}: ${handler.log}`);
                return handler.action(text, processor, ...args);
            }
        }
        // 未处理的错误，抛出
        throw error;
    }
}
```

---

## 八、API导出清单

**修改位置**：`src/utils/textProcessor.js` 导出新增函数

```javascript
// === 新增导出 ===

export {
    // 代码分析
    detectCodeMode,
    analyzeCpp,
    analyzePython,
    
    // 基础模式
    charBreakLine,
    sentenceAnalysis,
    removeSymbolsMode,
    
    // 组合选项处理器
    ComboOptionProcessor,
    
    // 历史栈
    HistoryManager,
    
    // 错误处理
    safeExecute,
    errorHandlers,
};
```

---

## 九、集成测试用例

### 9.1 Python代码测试

```javascript
const pythonInput = `def hello():
    print("Hello")
    if True:
        print("World")

class Test:
    def __init__(self):
        pass`;

const pythonExpected = [
    "def hello():",
    'print("Hello")',
    'print("World")',
    "class Test:",
    "def __init__(self):",
    "pass",
];

console.log(analyzePython(pythonInput));
// 应输出与 pythonExpected 匹配的结果
```

### 9.2 C++代码测试

```javascript
const cppInput = `#include <iostream>
int main() {
    std::cout << "Hello";
    if (true) {
        std::cout << "World";
    }
}`;

const cppExpected = [
    "#include <iostream>",
    "int main() {",
    'std::cout << "Hello";',
    'std::cout << "World";',
    "}",
];

console.log(analyzeCpp(cppInput));
// 应输出与 cppExpected 匹配的结果
```

### 9.3 AI链接补全测试

```javascript
const input1 = "Visit example.com or example.org";
// 应输出：["https://example.com", "https://example.org"]

const input2 = "Check http://test.com and example.net";
// 应输出：["http://test.com", "http://example.net"]
```

---

## 十、实现优先级

### 第一阶段（核心）

- [ ] 代码类型检测算法
- [ ] C++成对符号匹配
- [ ] Python缩进栈算法
- [ ] 整句识别规则

### 第二阶段（功能）

- [ ] AI分析链接处理流水线
- [ ] 中文分析词典/算法开关
- [ ] 组合选项互斥组检查
- [ ] 组合选项依赖解析
- [ ] 历史栈动态限制

### 第三阶段（体验）

- [ ] 随机分词刷新生成按钮
- [ ] 设置界面完整实现
- [ ] 全局持久化配置
- [ ] 错误处理完善

### 第四阶段（优化）

- [ ] 随机分词渐显动画
- [ ] 组合选项视觉反馈
- [ ] 历史栈可视化
- [ ] 分词结果高亮映射
