# Decide search 扩展实现文档

## 1. 项目概述

Decide search（Search Buddy）是一款强大的浏览器扩展，通过智能文本处理、多格式分析和高级剪贴板监控增强用户的搜索体验。

### 1.1 核心功能

- **智能剪贴板监控**：实时监控剪贴板内容变化，自动记录到历史
- **多格式文本分析**：检测和处理URL、文件路径、邮箱、电话号码等多种格式
- **智能文本拆分**：支持多种分隔规则和内容类型识别
- **搜索引擎集成**：内置多种搜索引擎，支持快速切换
- **链接历史管理**：记录和管理访问过的链接，支持导出和清空
- **仓库链接生成**：从GitHub仓库格式生成多种平台链接
- **路径转换工具**：在不同路径格式之间转换
- **响应式界面**：适配不同屏幕尺寸和布局

### 1.2 技术架构

- **Manifest V3**：使用最新的Chrome扩展开发标准
- **模块化设计**：清晰的代码组织结构
- **后台脚本**：处理上下文菜单和键盘快捷键
- **内容脚本**：处理页面级交互和通知
- **弹出窗口/侧边栏**：提供用户界面
- **工具库**：封装通用功能和逻辑

### 1.3 技术迭代方向

| 现有技术 | 迭代技术 | 优势 | 应用场景 |
| :--- | :--- | :--- | :--- |
| 定期检查剪贴板 | Clipboard API + 事件监听 | 实时响应，性能更好 | 剪贴板监控 |
| 正则表达式文本处理 | WebAssembly 分词库 | 速度更快，精度更高 | 中文分词 |
| chrome.storage.local | IndexedDB + Cache API | 存储容量更大，性能更好 | 历史记录管理 |
| 原生HTML/CSS/JS | Web Components + 现代CSS | 组件化，维护性更好 | 界面实现 |
| 消息传递 | MessagePort 长连接 | 减少通信开销，实时性更好 | 组件间通信 |
| 主线程处理 | Web Workers | 避免阻塞主线程，响应更快 | 耗时操作 |
| 基础错误处理 | 完整的错误边界 | 更可靠，用户体验更好 | 稳定性 |
| 模块化设计 | 插件架构 | 支持第三方扩展，扩展性更强 | 功能扩展 |

## 2. 核心功能实现

### 2.1 剪贴板监控系统

#### 2.1.1 功能描述

剪贴板监控系统实时检测剪贴板内容变化，自动记录到历史，并在内容变化时通知用户。支持通过快捷键（Alt+K）和侧边栏开关控制。

#### 2.1.2 实现原理

- **后台监控**：通过`chrome.storage.local`存储监控状态
- **内容脚本通知**：当剪贴板内容变化时，通过消息传递通知内容脚本显示页面通知
- **防抖处理**：使用防抖技术减少频繁的剪贴板检查和通知
- **安全处理**：对大内容进行截断处理，确保性能和稳定性

#### 2.1.3 关键代码

```javascript
// 剪贴板监控类
class ClipboardMonitor {
    constructor() {
        this.isMonitoring = false;
        this.init();
    }

    async init() {
        await this.initializeMonitoringState();
    }

    async handleNewClipboardContent(content) {
        // 安全处理：检查内容长度
        if (content.length > 10000) {
            content = content.substring(0, 100) + '...';
        }
        // 显示通知
        showPageNotification('检测到剪贴板内容变化', 'info');
    }
}

// 检查剪贴板内容
async function checkClipboard() {
    try {
        const text = await readFromClipboard();
        if (!text || text === lastClipboardContent) {
            return; // 内容未变化
        }
        lastClipboardContent = text;
        
        // 防抖处理
        if (clipboardDebounceTimer) {
            clearTimeout(clipboardDebounceTimer);
        }
        
        clipboardDebounceTimer = setTimeout(async () => {
            // 处理剪贴板内容
            await chrome.storage.local.set({
                lastClipboardContent: text,
                clipboardHistoryUpdated: timestamp
            });
            // 添加到剪贴板历史
            await addToClipboardHistory(text, 'clipboard-monitor');
        }, 100);
    } catch (error) {
        logger.error('读取剪贴板失败:', error);
    }
}
```

#### 2.1.4 迭代改进方案

**技术升级**：使用现代Clipboard API的`clipboardchange`事件（如果浏览器支持），结合Service Worker实现更高效的监控。

**关键代码改进**：

```javascript
// 现代剪贴板监控实现
class ModernClipboardMonitor {
    constructor() {
        this.isMonitoring = false;
        this.port = null;
        this.init();
    }

    async init() {
        await this.initializeMonitoringState();
        this.setupEventListeners();
    }

    setupEventListeners() {
        // 尝试使用Clipboard API的事件监听（现代浏览器）
        if (navigator.clipboard && navigator.clipboard.addEventListener) {
            try {
                navigator.clipboard.addEventListener('clipboardchange', async () => {
                    if (this.isMonitoring) {
                        await this.handleClipboardChange();
                    }
                });
                logger.info('使用现代Clipboard API事件监听');
            } catch (error) {
                // 回退到轮询方式
                this.setupPolling();
                logger.warn('Clipboard API事件监听失败，回退到轮询方式:', error);
            }
        } else {
            // 回退到轮询方式
            this.setupPolling();
            logger.info('使用轮询方式监控剪贴板');
        }
    }

    setupPolling() {
        // 使用requestAnimationFrame优化轮询
        let lastCheckTime = 0;
        const CHECK_INTERVAL = 1000; // 1秒检查一次

        const checkClipboard = async (timestamp) => {
            if (timestamp - lastCheckTime > CHECK_INTERVAL && this.isMonitoring) {
                lastCheckTime = timestamp;
                await this.handleClipboardChange();
            }
            if (this.isMonitoring) {
                requestAnimationFrame(checkClipboard);
            }
        };

        requestAnimationFrame(checkClipboard);
    }

    async handleClipboardChange() {
        try {
            const text = await navigator.clipboard.readText();
            if (!text || text === this.lastContent) {
                return;
            }

            this.lastContent = text;
            
            // 处理剪贴板内容
            const processed = await this.processContent(text);
            
            // 保存到存储
            await this.saveToStorage(text, processed);
            
            // 通知内容脚本
            await this.notifyContentScript(text, processed);
        } catch (error) {
            logger.error('处理剪贴板变化失败:', error);
        }
    }

    async processContent(text) {
        // 使用Web Worker处理耗时的内容分析
        return new Promise((resolve) => {
            if (!this.worker) {
                this.worker = new Worker('src/workers/contentProcessor.js');
            }

            this.worker.onmessage = (e) => {
                resolve(e.data);
            };

            this.worker.postMessage({ action: 'process', text });
        });
    }

    async saveToStorage(text, processed) {
        // 使用IndexedDB存储大量数据
        if (processed && processed.length > 1000) {
            await this.saveToIndexedDB({
                content: text,
                processed: processed,
                timestamp: Date.now()
            });
        } else {
            // 小数据使用chrome.storage
            await chrome.storage.local.set({
                lastClipboardContent: text,
                processedClipboardContent: processed,
                clipboardHistoryUpdated: Date.now()
            });
        }
    }

    async saveToIndexedDB(data) {
        // IndexedDB存储实现
        return new Promise((resolve, reject) => {
            const request = indexedDB.open('ClipboardStore', 1);
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains('clipboardHistory')) {
                    db.createObjectStore('clipboardHistory', { keyPath: 'id', autoIncrement: true });
                }
            };
            
            request.onsuccess = (event) => {
                const db = event.target.result;
                const transaction = db.transaction('clipboardHistory', 'readwrite');
                const store = transaction.objectStore('clipboardHistory');
                
                const addRequest = store.add({
                    ...data,
                    id: Date.now()
                });
                
                addRequest.onsuccess = () => resolve();
                addRequest.onerror = () => reject(addRequest.error);
            };
            
            request.onerror = () => reject(request.error);
        });
    }

    async notifyContentScript(text, processed) {
        // 使用MessagePort进行更高效的通信
        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
        if (tab) {
            try {
                // 建立长连接
                if (!this.port) {
                    this.port = chrome.tabs.connect(tab.id, { name: 'clipboard-monitor' });
                }
                
                this.port.postMessage({
                    action: 'clipboardChanged',
                    content: text,
                    processed: processed
                });
            } catch (error) {
                // 回退到传统消息传递
                await chrome.tabs.sendMessage(tab.id, {
                    action: 'clipboardChanged',
                    content: text,
                    processed: processed
                });
            }
        }
    }

    async toggleMonitoring() {
        this.isMonitoring = !this.isMonitoring;
        
        // 保存状态
        await chrome.storage.local.set({ clipboardMonitoring: this.isMonitoring });
        
        // 通知用户
        const message = this.isMonitoring ? '剪贴板监控已开启' : '剪贴板监控已关闭';
        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
        if (tab) {
            try {
                await chrome.tabs.sendMessage(tab.id, {
                    action: 'showNotification',
                    message: message,
                    type: this.isMonitoring ? 'success' : 'info'
                });
            } catch (error) {
                logger.warn('通知内容脚本失败:', error);
            }
        }
        
        return this.isMonitoring;
    }
}
```

### 2.2 智能文本处理系统

#### 2.2.1 功能描述

智能文本处理系统提供多种文本分析和处理功能，包括文本提取、链接检测、路径转换、代码命名拆分等。

#### 2.2.2 实现原理

- **多格式检测**：使用正则表达式和模式匹配检测不同类型的内容
- **智能拆分**：根据内容类型自动选择最适合的拆分规则
- **内容转换**：在不同格式之间进行转换，如路径格式转换
- **语义分析**：识别代码命名约定和文本结构

#### 2.2.3 关键代码

```javascript
// 智能文本拆分
export function splitText(text, delimiter = 'en-sentence') {
    if (!text || !text.trim()) return [];
    
    // 支持多规则同时应用
    const delimiters = Array.isArray(delimiter) ? delimiter : [delimiter];
    let results = [text.trim()];
    
    // 按优先级依次应用分隔规则
    for (const rule of delimiters) {
        const newResults = [];
        for (const segment of results) {
            newResults.push(...applySingleSplitRule(segment, rule));
        }
        results = newResults;
    }
    
    // 后处理：去重、过滤、长度校准
    return postProcessSplitResults(results);
}

// 多格式分析
export function analyzeTextForMultipleFormats(text) {
    const results = [];
    
    if (!text || !text.trim()) return results;

    // 路径检测和转换
    const pathResults = processPath(text);
    if (pathResults) {
        results.push({
            type: '路径转换',
            data: pathResults
        });
    }

    // URL提取
    const { extractedLinks } = processTextExtraction(text);
    if (extractedLinks.length > 0) {
        results.push({
            type: '链接提取',
            data: extractedLinks.map(url => ({ url }))
        });
    }

    // 仓库链接生成
    const repoResult = processLinkGeneration(text);
    if (repoResult) {
        results.push({
            type: '仓库链接',
            data: repoResult.generatedLinks.map(url => ({ url }))
        });
    }

    return results;
}
```

#### 2.2.4 迭代改进方案

**技术升级**：使用WebAssembly优化的分词库，结合AI-powered的文本分析API，提高处理速度和准确性。

**关键代码改进**：

```javascript
// WebAssembly优化的文本处理系统
class WasmTextProcessor {
    constructor() {
        this.loaded = false;
        this.wasmModule = null;
        this.init();
    }

    async init() {
        try {
            // 加载WebAssembly模块
            this.wasmModule = await this.loadWasmModule();
            this.loaded = true;
            logger.info('WebAssembly文本处理模块加载成功');
        } catch (error) {
            logger.error('WebAssembly模块加载失败:', error);
            // 回退到JavaScript实现
            this.loaded = false;
        }
    }

    async loadWasmModule() {
        // 加载编译为WebAssembly的Jieba分词库
        const response = await fetch('src/utils/wasm/jieba.wasm');
        const buffer = await response.arrayBuffer();
        const module = await WebAssembly.instantiate(buffer);
        return module.instance.exports;
    }

    async splitText(text, options = {}) {
        if (!text || !text.trim()) return [];

        if (this.loaded && this.wasmModule) {
            // 使用WebAssembly进行分词
            return await this.wasmSplitText(text, options);
        } else {
            // 回退到JavaScript实现
            return this.jsSplitText(text, options);
        }
    }

    async wasmSplitText(text, options) {
        // WebAssembly分词实现
        return new Promise((resolve) => {
            // 调用WebAssembly函数
            const resultPtr = this.wasmModule.splitText(
                this.stringToWasmMemory(text),
                text.length,
                options.mode || 0 // 0: 精确模式, 1: 全模式, 2: 搜索引擎模式
            );

            // 从WebAssembly内存中读取结果
            const result = this.readStringFromWasmMemory(resultPtr);
            resolve(JSON.parse(result));
        });
    }

    jsSplitText(text, options) {
        // 现有的JavaScript实现
        const delimiter = options.delimiter || 'en-sentence';
        const delimiters = Array.isArray(delimiter) ? delimiter : [delimiter];
        let results = [text.trim()];
        
        for (const rule of delimiters) {
            const newResults = [];
            for (const segment of results) {
                newResults.push(...this.applySingleSplitRule(segment, rule));
            }
            results = newResults;
        }
        
        return this.postProcessSplitResults(results);
    }

    async analyzeTextForMultipleFormats(text) {
        if (!text || !text.trim()) return [];

        // 使用Web Worker处理多格式分析
        return new Promise((resolve) => {
            const worker = new Worker('src/workers/textAnalyzer.js');
            
            worker.onmessage = (e) => {
                resolve(e.data);
                worker.terminate();
            };
            
            worker.onerror = (error) => {
                logger.error('文本分析Worker错误:', error);
                resolve([]);
                worker.terminate();
            };
            
            worker.postMessage({ action: 'analyze', text });
        });
    }

    // WebAssembly内存操作辅助方法
    stringToWasmMemory(str) {
        // 实现字符串到WebAssembly内存的转换
        // ...
    }

    readStringFromWasmMemory(ptr) {
        // 实现从WebAssembly内存读取字符串
        // ...
    }
}

// 导出单例
const textProcessor = new WasmTextProcessor();
export default textProcessor;
```

### 2.3 链接历史管理

#### 2.3.1 功能描述

链接历史管理系统记录用户访问过的链接，支持分类、搜索、导出和清空操作。特别增强了GitHub仓库的检测和管理。

#### 2.3.2 实现原理

- **增强的历史记录**：记录链接的元数据，如域名、类型、GitHub仓库信息等
- **去重处理**：自动移除重复的链接记录
- **历史限制**：支持设置历史记录数量限制
- **导出功能**：支持将历史记录导出为JSON文件

#### 2.3.3 关键代码

```javascript
// 添加到历史记录
export async function addToHistory(item) {
    try {
        if (!item || typeof item !== 'string' || !item.trim()) {
            logger.warn('Invalid history item provided');
            return false;
        }
        
        const { history, historyLimit } = await getSettings();
        const trimmedItem = item.trim();
        
        // 增强的历史记录条目
        const historyEntry = createHistoryEntry(trimmedItem);
        
        // 移除重复项并添加到前面
        const filteredHistory = history.filter(h => {
            const existing = typeof h === 'string' ? h : h.url;
            return existing !== historyEntry.url;
        });
        const newHistory = [historyEntry, ...filteredHistory];
        
        // 应用历史限制
        if (newHistory.length > historyLimit) {
            newHistory.length = historyLimit;
        }
        
        const success = await saveSettings({ history: newHistory });
        return success;
    } catch (error) {
        logger.error('Failed to add to history:', error);
        return false;
    }
}

// 创建增强的历史记录条目
export function createHistoryEntry(url) {
    const entry = {
        url,
        timestamp: new Date().toISOString(),
        type: 'other',
        domain: '',
        title: '',
        isGitHubRepo: false,
        repoInfo: null
    };
    
    try {
        const urlObj = new URL(url);
        entry.domain = urlObj.hostname;
        
        // GitHub仓库检测
        if (urlObj.hostname === 'github.com') {
            const pathParts = urlObj.pathname.split('/').filter(Boolean);
            if (pathParts.length >= 2) {
                entry.type = 'github';
                entry.isGitHubRepo = true;
                entry.repoInfo = {
                    username: pathParts[0],
                    repository: pathParts[1],
                    fullName: `${pathParts[0]}/${pathParts[1]}`
                };
                entry.title = entry.repoInfo.fullName;
            }
        }
    } catch (e) {
        // 非有效URL，视为搜索查询
        entry.type = 'search';
        entry.title = url.length > 30 ? url.substring(0, 30) + '...' : url;
    }
    
    return entry;
}
```

#### 2.3.4 迭代改进方案

**技术升级**：使用IndexedDB存储大量历史记录，结合Cache API进行缓存，提高性能和存储容量。

**关键代码改进**：

```javascript
// 增强的历史记录管理类
class EnhancedHistoryManager {
    constructor() {
        this.dbName = 'SearchBuddyHistory';
        this.dbVersion = 2;
        this.init();
    }

    async init() {
        await this.openDatabase();
        await this.migrateDatabase();
    }

    async openDatabase() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.dbVersion);

            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                
                // 创建历史记录存储
                if (!db.objectStoreNames.contains('history')) {
                    const historyStore = db.createObjectStore('history', { keyPath: 'id', autoIncrement: true });
                    historyStore.createIndex('timestamp', 'timestamp', { unique: false });
                    historyStore.createIndex('domain', 'domain', { unique: false });
                    historyStore.createIndex('type', 'type', { unique: false });
                }

                // 创建缓存存储
                if (!db.objectStoreNames.contains('cache')) {
                    db.createObjectStore('cache', { keyPath: 'key' });
                }
            };

            request.onsuccess = (event) => {
                this.db = event.target.result;
                resolve();
            };

            request.onerror = (event) => {
                reject(event.target.error);
            };
        });
    }

    async migrateDatabase() {
        // 从chrome.storage迁移到IndexedDB
        try {
            const { history } = await chrome.storage.local.get('history');
            if (history && history.length > 0) {
                await this.bulkAddHistory(history);
                // 迁移完成后清理chrome.storage
                await chrome.storage.local.remove('history');
                logger.info('历史记录迁移完成');
            }
        } catch (error) {
            logger.error('历史记录迁移失败:', error);
        }
    }

    async addHistory(item) {
        if (!item || typeof item !== 'string' || !item.trim()) {
            logger.warn('无效的历史记录项');
            return false;
        }

        const trimmedItem = item.trim();
        const historyEntry = this.createHistoryEntry(trimmedItem);

        try {
            // 检查是否已存在
            const exists = await this.historyExists(historyEntry.url);
            if (exists) {
                // 更新现有记录
                await this.updateHistory(historyEntry);
            } else {
                // 添加新记录
                await this.addHistoryEntry(historyEntry);
            }

            // 应用历史限制
            await this.applyHistoryLimit();

            return true;
        } catch (error) {
            logger.error('添加历史记录失败:', error);
            return false;
        }
    }

    async addHistoryEntry(entry) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction('history', 'readwrite');
            const store = transaction.objectStore('history');
            
            const request = store.add({
                ...entry,
                id: Date.now(),
                createdAt: new Date().toISOString()
            });

            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    }

    async historyExists(url) {
        return new Promise((resolve) => {
            const transaction = this.db.transaction('history', 'readonly');
            const store = transaction.objectStore('history');
            
            const index = store.index('url');
            const request = index.get(url);

            request.onsuccess = () => resolve(request.result !== undefined);
            request.onerror = () => resolve(false);
        });
    }

    async updateHistory(entry) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction('history', 'readwrite');
            const store = transaction.objectStore('history');
            
            const index = store.index('url');
            const request = index.get(entry.url);

            request.onsuccess = () => {
                if (request.result) {
                    const existingEntry = request.result;
                    const updatedEntry = {
                        ...existingEntry,
                        ...entry,
                        updatedAt: new Date().toISOString()
                    };
                    
                    const updateRequest = store.put(updatedEntry);
                    updateRequest.onsuccess = () => resolve();
                    updateRequest.onerror = () => reject(updateRequest.error);
                } else {
                    resolve();
                }
            };

            request.onerror = () => reject(request.error);
        });
    }

    async applyHistoryLimit() {
        const { historyLimit } = await getSettings();
        
        // 获取历史记录数量
        const count = await this.getHistoryCount();
        
        if (count > historyLimit) {
            // 删除最旧的记录
            const toDelete = count - historyLimit;
            await this.deleteOldestHistory(toDelete);
        }
    }

    async getHistoryCount() {
        return new Promise((resolve) => {
            const transaction = this.db.transaction('history', 'readonly');
            const store = transaction.objectStore('history');
            
            const request = store.count();
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => resolve(0);
        });
    }

    async deleteOldestHistory(count) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction('history', 'readwrite');
            const store = transaction.objectStore('history');
            const index = store.index('timestamp');
            
            const request = index.openCursor();
            let deleted = 0;

            request.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor && deleted < count) {
                    cursor.delete();
                    deleted++;
                    cursor.continue();
                } else {
                    resolve();
                }
            };

            request.onerror = () => reject(request.error);
        });
    }

    async getHistory(options = {}) {
        const { limit = 100, offset = 0, type = 'all' } = options;
        
        return new Promise((resolve) => {
            const transaction = this.db.transaction('history', 'readonly');
            const store = transaction.objectStore('history');
            const index = store.index('timestamp');
            
            const request = index.openCursor(null, 'prev'); // 按时间戳降序
            const results = [];
            let processed = 0;

            request.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor && processed < limit + offset) {
                    if (processed >= offset) {
                        if (type === 'all' || cursor.value.type === type) {
                            results.push(cursor.value);
                        }
                    }
                    processed++;
                    cursor.continue();
                } else {
                    resolve(results);
                }
            };

            request.onerror = () => resolve([]);
        });
    }

    async clearHistory() {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction('history', 'readwrite');
            const store = transaction.objectStore('history');
            
            const request = store.clear();
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    }

    createHistoryEntry(url) {
        // 现有的createHistoryEntry实现
        const entry = {
            url,
            timestamp: new Date().toISOString(),
            type: 'other',
            domain: '',
            title: '',
            isGitHubRepo: false,
            repoInfo: null
        };
        
        try {
            const urlObj = new URL(url);
            entry.domain = urlObj.hostname;
            
            if (urlObj.hostname === 'github.com') {
                const pathParts = urlObj.pathname.split('/').filter(Boolean);
                if (pathParts.length >= 2) {
                    entry.type = 'github';
                    entry.isGitHubRepo = true;
                    entry.repoInfo = {
                        username: pathParts[0],
                        repository: pathParts[1],
                        fullName: `${pathParts[0]}/${pathParts[1]}`
                    };
                    entry.title = entry.repoInfo.fullName;
                }
            }
        } catch (e) {
            entry.type = 'search';
            entry.title = url.length > 30 ? url.substring(0, 30) + '...' : url;
        }
        
        return entry;
    }
}

// 导出单例
const historyManager = new EnhancedHistoryManager();
export default historyManager;
```

### 2.4 剪贴板历史管理

#### 2.4.1 功能描述

剪贴板历史管理系统记录用户复制的内容，支持查看、编辑、恢复和批量操作。

#### 2.4.2 实现原理

- **增强的剪贴板记录**：记录复制内容的来源、时间戳等元数据
- **编辑功能**：支持编辑剪贴板历史中的内容
- **恢复功能**：支持恢复编辑过的内容到原始状态
- **批量操作**：支持批量选择和删除剪贴板历史项

#### 2.4.3 关键代码

```javascript
// 添加到剪贴板历史
export async function addToClipboardHistory(content, source = 'clipboard') {
    try {
        if (!content || !content.trim()) {
            logger.warn('Invalid clipboard content provided');
            return false;
        }
        
        const { clipboardHistory, clipboardHistoryLimit } = await getSettings();
        const trimmedContent = content.trim();
        
        // 创建剪贴板历史条目
        const entry = {
            id: Date.now().toString(),
            content: trimmedContent,
            source,
            timestamp: new Date().toISOString(),
            isEdited: false,
            originalContent: trimmedContent
        };
        
        // 移除重复内容
        const filteredHistory = clipboardHistory.filter(item => item.content !== trimmedContent);
        
        // 添加新条目到前面
        const newHistory = [entry, ...filteredHistory];
        
        // 应用历史限制
        if (newHistory.length > clipboardHistoryLimit) {
            newHistory.length = clipboardHistoryLimit;
        }
        
        const success = await saveSettings({ clipboardHistory: newHistory });
        return success;
    } catch (error) {
        logger.error('Failed to add to clipboard history:', error);
        return false;
    }
}

// 更新剪贴板历史项
export async function updateClipboardHistoryItem(id, newContent) {
    try {
        const { clipboardHistory } = await getSettings();
        const updatedHistory = clipboardHistory.map(item => {
            if (item.id === id) {
                return {
                    ...item,
                    content: newContent.trim(),
                    isEdited: true,
                    editedAt: new Date().toISOString()
                };
            }
            return item;
        });
        
        const success = await saveSettings({ clipboardHistory: updatedHistory });
        return success;
    } catch (error) {
        logger.error('Failed to update clipboard history item:', error);
        return false;
    }
}
```

#### 2.4.4 迭代改进方案

**技术升级**：使用IndexedDB存储剪贴板历史，结合Web Workers处理批量操作，提高性能和可靠性。

**关键代码改进**：

```javascript
// 增强的剪贴板历史管理类
class EnhancedClipboardHistory {
    constructor() {
        this.dbName = 'SearchBuddyClipboard';
        this.dbVersion = 1;
        this.init();
    }

    async init() {
        await this.openDatabase();
    }

    async openDatabase() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.dbVersion);

            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                
                if (!db.objectStoreNames.contains('clipboardHistory')) {
                    const store = db.createObjectStore('clipboardHistory', { keyPath: 'id' });
                    store.createIndex('timestamp', 'timestamp', { unique: false });
                    store.createIndex('source', 'source', { unique: false });
                }
            };

            request.onsuccess = (event) => {
                this.db = event.target.result;
                resolve();
            };

            request.onerror = (event) => {
                reject(event.target.error);
            };
        });
    }

    async addToHistory(content, source = 'clipboard') {
        if (!content || !content.trim()) {
            logger.warn('无效的剪贴板内容');
            return false;
        }

        const trimmedContent = content.trim();
        const entry = {
            id: Date.now().toString(),
            content: trimmedContent,
            source,
            timestamp: new Date().toISOString(),
            isEdited: false,
            originalContent: trimmedContent
        };

        try {
            // 检查是否重复
            const isDuplicate = await this.isDuplicateContent(trimmedContent);
            if (isDuplicate) {
                return true; // 已存在，不需要添加
            }

            // 添加到数据库
            await this.addEntry(entry);

            // 应用历史限制
            await this.applyHistoryLimit();

            return true;
        } catch (error) {
            logger.error('添加剪贴板历史失败:', error);
            return false;
        }
    }

    async isDuplicateContent(content) {
        return new Promise((resolve) => {
            const transaction = this.db.transaction('clipboardHistory', 'readonly');
            const store = transaction.objectStore('clipboardHistory');
            
            const request = store.openCursor();
            let found = false;

            request.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor) {
                    if (cursor.value.content === content) {
                        found = true;
                    } else {
                        cursor.continue();
                    }
                } else {
                    resolve(found);
                }
            };

            request.onerror = () => resolve(false);
        });
    }

    async addEntry(entry) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction('clipboardHistory', 'readwrite');
            const store = transaction.objectStore('clipboardHistory');
            
            const request = store.add(entry);
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    }

    async applyHistoryLimit() {
        const { clipboardHistoryLimit } = await getSettings();
        
        const count = await this.getHistoryCount();
        
        if (count > clipboardHistoryLimit) {
            const toDelete = count - clipboardHistoryLimit;
            await this.deleteOldestEntries(toDelete);
        }
    }

    async getHistoryCount() {
        return new Promise((resolve) => {
            const transaction = this.db.transaction('clipboardHistory', 'readonly');
            const store = transaction.objectStore('clipboardHistory');
            
            const request = store.count();
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => resolve(0);
        });
    }

    async deleteOldestEntries(count) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction('clipboardHistory', 'readwrite');
            const store = transaction.objectStore('clipboardHistory');
            const index = store.index('timestamp');
            
            const request = index.openCursor();
            let deleted = 0;

            request.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor && deleted < count) {
                    cursor.delete();
                    deleted++;
                    cursor.continue();
                } else {
                    resolve();
                }
            };

            request.onerror = () => reject(request.error);
        });
    }

    async getHistory(options = {}) {
        const { limit = 50, offset = 0 } = options;
        
        return new Promise((resolve) => {
            const transaction = this.db.transaction('clipboardHistory', 'readonly');
            const store = transaction.objectStore('clipboardHistory');
            const index = store.index('timestamp');
            
            const request = index.openCursor(null, 'prev'); // 按时间戳降序
            const results = [];
            let processed = 0;

            request.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor && processed < limit + offset) {
                    if (processed >= offset) {
                        results.push(cursor.value);
                    }
                    processed++;
                    cursor.continue();
                } else {
                    resolve(results);
                }
            };

            request.onerror = () => resolve([]);
        });
    }

    async updateItem(id, newContent) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction('clipboardHistory', 'readwrite');
            const store = transaction.objectStore('clipboardHistory');
            
            const request = store.get(id);

            request.onsuccess = () => {
                if (request.result) {
                    const entry = request.result;
                    const updatedEntry = {
                        ...entry,
                        content: newContent.trim(),
                        isEdited: true,
                        editedAt: new Date().toISOString()
                    };
                    
                    const updateRequest = store.put(updatedEntry);
                    updateRequest.onsuccess = () => resolve(true);
                    updateRequest.onerror = () => reject(updateRequest.error);
                } else {
                    resolve(false);
                }
            };

            request.onerror = () => reject(request.error);
        });
    }

    async deleteItem(id) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction('clipboardHistory', 'readwrite');
            const store = transaction.objectStore('clipboardHistory');
            
            const request = store.delete(id);
            request.onsuccess = () => resolve(true);
            request.onerror = () => resolve(false);
        });
    }

    async deleteMultipleItems(ids) {
        // 使用批量操作提高性能
        return new Promise((resolve) => {
            const transaction = this.db.transaction('clipboardHistory', 'readwrite');
            const store = transaction.objectStore('clipboardHistory');
            
            let completed = 0;
            let errors = 0;

            ids.forEach(id => {
                const request = store.delete(id);
                request.onsuccess = () => {
                    completed++;
                    if (completed + errors === ids.length) {
                        resolve(completed === ids.length);
                    }
                };
                request.onerror = () => {
                    errors++;
                    if (completed + errors === ids.length) {
                        resolve(completed === ids.length);
                    }
                };
            });
        });
    }

    async restoreItem(id) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction('clipboardHistory', 'readwrite');
            const store = transaction.objectStore('clipboardHistory');
            
            const request = store.get(id);

            request.onsuccess = () => {
                if (request.result && request.result.isEdited) {
                    const entry = request.result;
                    const restoredEntry = {
                        ...entry,
                        content: entry.originalContent,
                        isEdited: false,
                        editedAt: null
                    };
                    
                    const updateRequest = store.put(restoredEntry);
                    updateRequest.onsuccess = () => resolve(true);
                    updateRequest.onerror = () => reject(updateRequest.error);
                } else {
                    resolve(false);
                }
            };

            request.onerror = () => reject(request.error);
        });
    }

    async clearHistory() {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction('clipboardHistory', 'readwrite');
            const store = transaction.objectStore('clipboardHistory');
            
            const request = store.clear();
            request.onsuccess = () => resolve(true);
            request.onerror = () => resolve(false);
        });
    }
}

// 导出单例
const clipboardHistoryManager = new EnhancedClipboardHistory();
export default clipboardHistoryManager;
```

### 2.5 搜索引擎集成

#### 2.5.1 功能描述

搜索引擎集成系统内置多种搜索引擎，支持快速切换和自定义。

#### 2.5.2 实现原理

- **内置搜索引擎**：预配置多种常用搜索引擎
- **搜索引擎模板**：使用模板系统构建搜索URL
- **默认引擎设置**：支持设置默认搜索引擎

#### 2.5.3 关键代码

```javascript
// 默认设置与增强的搜索引擎
export const DEFAULTS = {
    searchEngines: [
        { name: 'Bing', template: 'https://www.bing.com/search?q=%s', category: 'general' },
        { name: 'Google', template: 'https://www.google.com/search?q=%s', category: 'general' },
        { name: 'Google Scholar', template: 'https://scholar.google.com/scholar?q=%s', category: 'academic' },
        { name: 'Metaso', template: 'https://metaso.cn/search?q=%s', category: