# Decide search 扩展实现文档

## 1. 项目概述

Decide search（Search Buddy）是一款强大的浏览器扩展，通过智能文本处理、多格式分析和高级剪贴板监控增强用户的搜索体验。

### 1.1 核心功能

- **智能剪贴板监控**：实时监控剪贴板内容变化，自动记录到历史
- **多格式文本分析**：检测和处理URL、文件路径、邮箱、电话号码等多种格式
- **智能文本拆分**：支持多种分隔规则和内容类型识别
- **搜索引擎集成**：内置多种搜索引擎，支持快速切换
- **链接历史管理**：记录和管理访问过的链接，支持导出和清空
- **仓库链接生成**：从GitHub仓库格式生成多种平台链接
- **路径转换工具**：在不同路径格式之间转换
- **响应式界面**：适配不同屏幕尺寸和布局

### 1.2 技术架构

- **Manifest V3**：使用最新的Chrome扩展开发标准
- **模块化设计**：清晰的代码组织结构
- **后台脚本**：处理上下文菜单和键盘快捷键
- **内容脚本**：处理页面级交互和通知
- **弹出窗口/侧边栏**：提供用户界面
- **工具库**：封装通用功能和逻辑

## 2. 核心功能实现

### 2.1 剪贴板监控系统

#### 2.1.1 功能描述

剪贴板监控系统实时检测剪贴板内容变化，自动记录到历史，并在内容变化时通知用户。支持通过快捷键（Alt+K）和侧边栏开关控制。

#### 2.1.2 实现原理

- **后台监控**：通过`chrome.storage.local`存储监控状态
- **内容脚本通知**：当剪贴板内容变化时，通过消息传递通知内容脚本显示页面通知
- **防抖处理**：使用防抖技术减少频繁的剪贴板检查和通知
- **安全处理**：对大内容进行截断处理，确保性能和稳定性

#### 2.1.3 关键代码

```javascript
// 剪贴板监控类
class ClipboardMonitor {
    constructor() {
        this.isMonitoring = false;
        this.init();
    }

    async init() {
        await this.initializeMonitoringState();
    }

    async handleNewClipboardContent(content) {
        // 安全处理：检查内容长度
        if (content.length > 10000) {
            content = content.substring(0, 100) + '...';
        }
        // 显示通知
        showPageNotification('检测到剪贴板内容变化', 'info');
    }
}

// 检查剪贴板内容
async function checkClipboard() {
    try {
        const text = await readFromClipboard();
        if (!text || text === lastClipboardContent) {
            return; // 内容未变化
        }
        lastClipboardContent = text;
        
        // 防抖处理
        if (clipboardDebounceTimer) {
            clearTimeout(clipboardDebounceTimer);
        }
        
        clipboardDebounceTimer = setTimeout(async () => {
            // 处理剪贴板内容
            await chrome.storage.local.set({
                lastClipboardContent: text,
                clipboardHistoryUpdated: timestamp
            });
            // 添加到剪贴板历史
            await addToClipboardHistory(text, 'clipboard-monitor');
        }, 100);
    } catch (error) {
        logger.error('读取剪贴板失败:', error);
    }
}
```

### 2.2 智能文本处理系统

#### 2.2.1 功能描述

智能文本处理系统提供多种文本分析和处理功能，包括文本提取、链接检测、路径转换、代码命名拆分等。

#### 2.2.2 实现原理

- **多格式检测**：使用正则表达式和模式匹配检测不同类型的内容
- **智能拆分**：根据内容类型自动选择最适合的拆分规则
- **内容转换**：在不同格式之间进行转换，如路径格式转换
- **语义分析**：识别代码命名约定和文本结构

#### 2.2.3 关键代码

```javascript
// 智能文本拆分
export function splitText(text, delimiter = 'en-sentence') {
    if (!text || !text.trim()) return [];
    
    // 支持多规则同时应用
    const delimiters = Array.isArray(delimiter) ? delimiter : [delimiter];
    let results = [text.trim()];
    
    // 按优先级依次应用分隔规则
    for (const rule of delimiters) {
        const newResults = [];
        for (const segment of results) {
            newResults.push(...applySingleSplitRule(segment, rule));
        }
        results = newResults;
    }
    
    // 后处理：去重、过滤、长度校准
    return postProcessSplitResults(results);
}

// 多格式分析
export function analyzeTextForMultipleFormats(text) {
    const results = [];
    
    if (!text || !text.trim()) return results;

    // 路径检测和转换
    const pathResults = processPath(text);
    if (pathResults) {
        results.push({
            type: '路径转换',
            data: pathResults
        });
    }

    // URL提取
    const { extractedLinks } = processTextExtraction(text);
    if (extractedLinks.length > 0) {
        results.push({
            type: '链接提取',
            data: extractedLinks.map(url => ({ url }))
        });
    }

    // 仓库链接生成
    const repoResult = processLinkGeneration(text);
    if (repoResult) {
        results.push({
            type: '仓库链接',
            data: repoResult.generatedLinks.map(url => ({ url }))
        });
    }

    return results;
}
```

### 2.3 链接历史管理

#### 2.3.1 功能描述

链接历史管理系统记录用户访问过的链接，支持分类、搜索、导出和清空操作。特别增强了GitHub仓库的检测和管理。

#### 2.3.2 实现原理

- **增强的历史记录**：记录链接的元数据，如域名、类型、GitHub仓库信息等
- **去重处理**：自动移除重复的链接记录
- **历史限制**：支持设置历史记录数量限制
- **导出功能**：支持将历史记录导出为JSON文件

#### 2.3.3 关键代码

```javascript
// 添加到历史记录
export async function addToHistory(item) {
    try {
        if (!item || typeof item !== 'string' || !item.trim()) {
            logger.warn('Invalid history item provided');
            return false;
        }
        
        const { history, historyLimit } = await getSettings();
        const trimmedItem = item.trim();
        
        // 增强的历史记录条目
        const historyEntry = createHistoryEntry(trimmedItem);
        
        // 移除重复项并添加到前面
        const filteredHistory = history.filter(h => {
            const existing = typeof h === 'string' ? h : h.url;
            return existing !== historyEntry.url;
        });
        const newHistory = [historyEntry, ...filteredHistory];
        
        // 应用历史限制
        if (newHistory.length > historyLimit) {
            newHistory.length = historyLimit;
        }
        
        const success = await saveSettings({ history: newHistory });
        return success;
    } catch (error) {
        logger.error('Failed to add to history:', error);
        return false;
    }
}

// 创建增强的历史记录条目
export function createHistoryEntry(url) {
    const entry = {
        url,
        timestamp: new Date().toISOString(),
        type: 'other',
        domain: '',
        title: '',
        isGitHubRepo: false,
        repoInfo: null
    };
    
    try {
        const urlObj = new URL(url);
        entry.domain = urlObj.hostname;
        
        // GitHub仓库检测
        if (urlObj.hostname === 'github.com') {
            const pathParts = urlObj.pathname.split('/').filter(Boolean);
            if (pathParts.length >= 2) {
                entry.type = 'github';
                entry.isGitHubRepo = true;
                entry.repoInfo = {
                    username: pathParts[0],
                    repository: pathParts[1],
                    fullName: `${pathParts[0]}/${pathParts[1]}`
                };
                entry.title = entry.repoInfo.fullName;
            }
        }
    } catch (e) {
        // 非有效URL，视为搜索查询
        entry.type = 'search';
        entry.title = url.length > 30 ? url.substring(0, 30) + '...' : url;
    }
    
    return entry;
}
```

### 2.4 剪贴板历史管理

#### 2.4.1 功能描述

剪贴板历史管理系统记录用户复制的内容，支持查看、编辑、恢复和批量操作。

#### 2.4.2 实现原理

- **增强的剪贴板记录**：记录复制内容的来源、时间戳等元数据
- **编辑功能**：支持编辑剪贴板历史中的内容
- **恢复功能**：支持恢复编辑过的内容到原始状态
- **批量操作**：支持批量选择和删除剪贴板历史项

#### 2.4.3 关键代码

```javascript
// 添加到剪贴板历史
export async function addToClipboardHistory(content, source = 'clipboard') {
    try {
        if (!content || !content.trim()) {
            logger.warn('Invalid clipboard content provided');
            return false;
        }
        
        const { clipboardHistory, clipboardHistoryLimit } = await getSettings();
        const trimmedContent = content.trim();
        
        // 创建剪贴板历史条目
        const entry = {
            id: Date.now().toString(),
            content: trimmedContent,
            source,
            timestamp: new Date().toISOString(),
            isEdited: false,
            originalContent: trimmedContent
        };
        
        // 移除重复内容
        const filteredHistory = clipboardHistory.filter(item => item.content !== trimmedContent);
        
        // 添加新条目到前面
        const newHistory = [entry, ...filteredHistory];
        
        // 应用历史限制
        if (newHistory.length > clipboardHistoryLimit) {
            newHistory.length = clipboardHistoryLimit;
        }
        
        const success = await saveSettings({ clipboardHistory: newHistory });
        return success;
    } catch (error) {
        logger.error('Failed to add to clipboard history:', error);
        return false;
    }
}

// 更新剪贴板历史项
export async function updateClipboardHistoryItem(id, newContent) {
    try {
        const { clipboardHistory } = await getSettings();
        const updatedHistory = clipboardHistory.map(item => {
            if (item.id === id) {
                return {
                    ...item,
                    content: newContent.trim(),
                    isEdited: true,
                    editedAt: new Date().toISOString()
                };
            }
            return item;
        });
        
        const success = await saveSettings({ clipboardHistory: updatedHistory });
        return success;
    } catch (error) {
        logger.error('Failed to update clipboard history item:', error);
        return false;
    }
}
```

### 2.5 搜索引擎集成

#### 2.5.1 功能描述

搜索引擎集成系统内置多种搜索引擎，支持快速切换和自定义。

#### 2.5.2 实现原理

- **内置搜索引擎**：预配置多种常用搜索引擎
- **搜索引擎模板**：使用模板系统构建搜索URL
- **默认引擎设置**：支持设置默认搜索引擎

#### 2.5.3 关键代码

```javascript
// 默认设置与增强的搜索引擎
export const DEFAULTS = {
    searchEngines: [
        { name: 'Bing', template: 'https://www.bing.com/search?q=%s', category: 'general' },
        { name: 'Google', template: 'https://www.google.com/search?q=%s', category: 'general' },
        { name: 'Google Scholar', template: 'https://scholar.google.com/scholar?q=%s', category: 'academic' },
        { name: 'Metaso', template: 'https://metaso.cn/search?q=%s', category: 'ai' },
        { name: 'Sogou', template: 'https://www.sogou.com/web?query=%s', category: 'general' },
        { name: 'GitHub', template: 'https://github.com/search?q=%s', category: 'code' },
        { name: 'Stack Overflow', template: 'https://stackoverflow.com/search?q=%s', category: 'code' },
        { name: 'MDN', template: 'https://developer.mozilla.org/en-US/search?q=%s', category: 'docs' },
    ],
    // 其他默认设置...
};

// 搜索功能
function handleSearch() {
    const query = elements.search_input.value.trim();
    if (!query) return;

    if (isURL(query)) {
        window.open(query, '_blank');
        addToHistoryEnhanced(query);
        return;
    }
    
    let selectedEngineName = appState.settings.defaultEngine;
    if (elements.engine_select && elements.engine_select.value) {
        selectedEngineName = elements.engine_select.value;
    }
    
    const selectedEngine = appState.settings.searchEngines.find(e => e.name === selectedEngineName);
    
    if (selectedEngine) {
        const searchUrl = selectedEngine.template.replace('%s', encodeURIComponent(query));
        window.open(searchUrl, '_blank');
        addToHistoryEnhanced(query);
    }
}
```

## 3. 技术架构

### 3.1 文件结构

```
src/
├── background/           # 后台脚本
│   └── index.js         # 后台主逻辑
├── content/             # 内容脚本
│   └── index.js         # 页面级交互
├── popup/               # 弹出窗口和侧边栏
│   ├── index.html       # 界面HTML
│   ├── main.js          # 主逻辑
│   ├── style.css        # 样式
│   └── new-style.css    # 新样式
├── settings/            # 设置页面
│   ├── index.html       # 界面HTML
│   ├── main.js          # 主逻辑
│   ├── style.css        # 样式
│   └── new-style.css    # 新样式
└── utils/               # 工具函数库
    ├── clipboard.js     # 剪贴板操作
    ├── communication.js # 通信工具
    ├── linkHistory.js   # 链接历史管理
    ├── logger.js        # 日志工具
    ├── storage.js       # 存储管理
    └── textProcessor.js # 文本处理和分析
```

### 3.2 通信机制

- **后台脚本与内容脚本**：使用`chrome.runtime.onMessage`和`chrome.tabs.sendMessage`
- **后台脚本与弹出窗口**：使用`chrome.runtime.onMessage`和`chrome.runtime.sendMessage`
- **存储同步**：使用`chrome.storage.local`和`chrome.storage.onChanged`监听器

### 3.3 数据流

1. **用户输入** → 弹出窗口/侧边栏
2. **文本分析** → `textProcessor.js`
3. **存储操作** → `storage.js`
4. **剪贴板操作** → `clipboard.js`
5. **历史记录** → `linkHistory.js`和`storage.js`
6. **后台处理** → `background/index.js`
7. **页面通知** → `content/index.js`

## 4. 用户界面

### 4.1 弹出窗口/侧边栏

- **搜索输入框**：支持自适应高度和手动调整
- **功能开关**：提取、链接生成、多格式分析
- **剪贴板监控**：状态显示和控制
- **历史记录**：可展开/折叠的链接历史
- **剪贴板历史**：可展开/折叠的剪贴板历史
- **响应式布局**：适配不同宽度和高度

### 4.2 内容脚本通知

- **页面通知**：当剪贴板内容变化时显示
- **通知样式**：滑入/滑出动画，不同类型的通知有不同颜色

### 4.3 上下文菜单

- **右键菜单**：选中文本后显示"Search with Buddy"选项
- **快捷操作**：直接打开侧边栏并搜索选中的文本

## 5. 键盘快捷键

| 快捷键 | 功能 |
|--------|------|
| Alt+L | 打开侧边栏 |
| Alt+K | 切换剪贴板监控 |
| Alt+Shift+S | 快速搜索选中的文本 |

## 6. 性能优化

### 6.1 防抖处理

- **剪贴板监控**：使用防抖减少频繁的剪贴板检查
- **文本输入**：使用防抖减少频繁的文本分析和UI更新

### 6.2 懒加载和条件渲染

- **历史记录**：仅在展开时渲染历史记录
- **剪贴板历史**：仅在展开时渲染剪贴板历史

### 6.3 批量DOM操作

- **使用文档片段**：减少DOM操作次数，提高渲染性能
- **一次性更新**：批量更新DOM，减少重绘和回流

### 6.4 存储优化

- **历史限制**：设置历史记录数量限制，避免存储过多数据
- **去重处理**：自动移除重复的历史记录，节省存储空间

## 7. 安全考虑

### 7.1 权限管理

- **最小权限原则**：仅请求必要的权限
- **可选权限**：将非必要权限设置为可选

### 7.2 数据安全

- **内容限制**：对大内容进行截断处理，避免内存溢出
- **错误处理**：完善的错误处理机制，提高稳定性

### 7.3 隐私保护

- **本地存储**：所有数据存储在本地，不上传至服务器
- **用户控制**：用户可以随时清空历史记录和剪贴板历史

## 8. 未来扩展可能性

- **更多搜索引擎**：支持添加和管理自定义搜索引擎
- **更丰富的文本分析**：增强对更多格式的支持
- **云同步**：支持跨设备同步设置和历史记录
- **主题定制**：支持更多主题和自定义样式
- **更多集成**：与更多服务和平台集成

## 9. 总结

Decide search（Search Buddy）是一款功能强大的浏览器扩展，通过智能文本处理、多格式分析和高级剪贴板监控，显著增强了用户的搜索体验。其模块化设计、性能优化和用户友好的界面使其成为一个实用且高效的工具。

### 9.1 核心优势

- **智能文本处理**：支持多种文本格式的检测和处理
- **强大的剪贴板管理**：实时监控和历史记录
- **增强的链接管理**：智能分类和GitHub仓库检测
- **用户友好界面**：响应式设计和流畅的用户体验
- **性能优化**：防抖处理和懒加载，确保流畅运行

### 9.2 技术亮点

- **模块化架构**：清晰的代码组织和职责分离
- **智能算法**：多种文本分析和处理算法
- **实时监控**：高效的剪贴板监控机制
- **响应式设计**：适配不同屏幕尺寸
- **扩展性**：良好的扩展性和可维护性

这款扩展不仅提供了基础的搜索功能，还通过智能文本处理和剪贴板管理，为用户提供了更高效、更便捷的信息处理方式，是现代浏览器用户的得力助手。