# Decide search 扩展实现文档

## 1. 项目概述

Decide search（Search Buddy）是一款强大的浏览器扩展，通过智能文本处理、多格式分析和高级剪贴板监控增强用户的搜索体验。

### 1.1 核心功能

- **智能剪贴板监控**：实时监控剪贴板内容变化，自动记录到历史
- **多格式文本分析**：检测和处理URL、文件路径、邮箱、电话号码等多种格式
- **智能文本拆分**：支持多种分隔规则和内容类型识别
- **搜索引擎集成**：内置多种搜索引擎，支持快速切换
- **链接历史管理**：记录和管理访问过的链接，支持导出和清空
- **仓库链接生成**：从GitHub仓库格式生成多种平台链接
- **路径转换工具**：在不同路径格式之间转换
- **响应式界面**：适配不同屏幕尺寸和布局

### 1.2 技术架构

- **Manifest V3**：使用最新的Chrome扩展开发标准
- **模块化设计**：清晰的代码组织结构
- **后台脚本**：处理上下文菜单和键盘快捷键
- **内容脚本**：处理页面级交互和通知
- **弹出窗口/侧边栏**：提供用户界面
- **工具库**：封装通用功能和逻辑

### 1.3 技术迭代方向

| 现有技术 | 迭代技术 | 优势 | 应用场景 |
| :--- | :--- | :--- | :--- |
| 定期检查剪贴板 | Clipboard API + 事件监听 | 实时响应，性能更好 | 剪贴板监控 |
| 正则表达式文本处理 | WebAssembly 分词库 | 速度更快，精度更高 | 中文分词 |
| chrome.storage.local | IndexedDB + Cache API | 存储容量更大，性能更好 | 历史记录管理 |
| 原生HTML/CSS/JS | Web Components + 现代CSS | 组件化，维护性更好 | 界面实现 |
| 消息传递 | MessagePort 长连接 | 减少通信开销，实时性更好 | 组件间通信 |
| 主线程处理 | Web Workers | 避免阻塞主线程，响应更快 | 耗时操作 |
| 基础错误处理 | 完整的错误边界 | 更可靠，用户体验更好 | 稳定性 |
| 模块化设计 | 插件架构 | 支持第三方扩展，扩展性更强 | 功能扩展 |

## 2. 核心功能实现

### 2.1 剪贴板监控系统

#### 2.1.1 功能描述

剪贴板监控系统实时检测剪贴板内容变化，自动记录到历史，并在内容变化时通知用户。支持通过快捷键（Alt+K）和侧边栏开关控制。

#### 2.1.2 实现原理

- **后台监控**：通过`chrome.storage.local`存储监控状态
- **内容脚本通知**：当剪贴板内容变化时，通过消息传递通知内容脚本显示页面通知
- **防抖处理**：使用防抖技术减少频繁的剪贴板检查和通知
- **安全处理**：对大内容进行截断处理，确保性能和稳定性

#### 2.1.3 关键代码

```javascript
// 剪贴板监控类
class ClipboardMonitor {
    constructor() {
        this.isMonitoring = false;
        this.init();
    }

    async init() {
        await this.initializeMonitoringState();
    }

    async handleNewClipboardContent(content) {
        // 安全处理：检查内容长度
        if (content.length > 10000) {
            content = content.substring(0, 100) + '...';
        }
        // 显示通知
        showPageNotification('检测到剪贴板内容变化', 'info');
    }
}

// 检查剪贴板内容
async function checkClipboard() {
    try {
        const text = await readFromClipboard();
        if (!text || text === lastClipboardContent) {
            return; // 内容未变化
        }
        lastClipboardContent = text;
        
        // 防抖处理
        if (clipboardDebounceTimer) {
            clearTimeout(clipboardDebounceTimer);
        }
        
        clipboardDebounceTimer = setTimeout(async () => {
            // 处理剪贴板内容
            await chrome.storage.local.set({
                lastClipboardContent: text,
                clipboardHistoryUpdated: timestamp
            });
            // 添加到剪贴板历史
            await addToClipboardHistory(text, 'clipboard-monitor');
        }, 100);
    } catch (error) {
        logger.error('读取剪贴板失败:', error);
    }
}
```

#### 2.1.4 迭代改进方案

**技术升级**：使用现代Clipboard API的`clipboardchange`事件（如果浏览器支持），结合Service Worker实现更高效的监控。

**关键代码改进**：

```javascript
// 现代剪贴板监控实现
class ModernClipboardMonitor {
    constructor() {
        this.isMonitoring = false;
        this.port = null;
        this.init();
    }

    async init() {
        await this.initializeMonitoringState();
        this.setupEventListeners();
    }

    setupEventListeners() {
        // 尝试使用Clipboard API的事件监听（现代浏览器）
        if (navigator.clipboard && navigator.clipboard.addEventListener) {
            try {
                navigator.clipboard.addEventListener('clipboardchange', async () => {
                    if (this.isMonitoring) {
                        await this.handleClipboardChange();
                    }
                });
                logger.info('使用现代Clipboard API事件监听');
            } catch (error) {
                // 回退到轮询方式
                this.setupPolling();
                logger.warn('Clipboard API事件监听失败，回退到轮询方式:', error);
            }
        } else {
            // 回退到轮询方式
            this.setupPolling();
            logger.info('使用轮询方式监控剪贴板');
        }
    }

    setupPolling() {
        // 使用requestAnimationFrame优化轮询
        let lastCheckTime = 0;
        const CHECK_INTERVAL = 1000; // 1秒检查一次

        const checkClipboard = async (timestamp) => {
            if (timestamp - lastCheckTime > CHECK_INTERVAL && this.isMonitoring) {
                lastCheckTime = timestamp;
                await this.handleClipboardChange();
            }
            if (this.isMonitoring) {
                requestAnimationFrame(checkClipboard);
            }
        };

        requestAnimationFrame(checkClipboard);
    }

    async handleClipboardChange() {
        try {
            const text = await navigator.clipboard.readText();
            if (!text || text === this.lastContent) {
                return;
            }

            this.lastContent = text;
            
            // 处理剪贴板内容
            const processed = await this.processContent(text);
            
            // 保存到存储
            await this.saveToStorage(text, processed);
            
            // 通知内容脚本
            await this.notifyContentScript(text, processed);
        } catch (error) {
            logger.error('处理剪贴板变化失败:', error);
        }
    }

    async processContent(text) {
        // 使用Web Worker处理耗时的内容分析
        return new Promise((resolve) => {
            if (!this.worker) {
                this.worker = new Worker('src/workers/contentProcessor.js');
            }

            this.worker.onmessage = (e) => {
                resolve(e.data);
            };

            this.worker.postMessage({ action: 'process', text });
        });
    }

    async saveToStorage(text, processed) {
        // 使用IndexedDB存储大量数据
        if (processed && processed.length > 1000) {
            await this.saveToIndexedDB({
                content: text,
                processed: processed,
                timestamp: Date.now()
            });
        } else {
            // 小数据使用chrome.storage
            await chrome.storage.local.set({
                lastClipboardContent: text,
                processedClipboardContent: processed,
                clipboardHistoryUpdated: Date.now()
            });
        }
    }

    async saveToIndexedDB(data) {
        // IndexedDB存储实现
        return new Promise((resolve, reject) => {
            const request = indexedDB.open('ClipboardStore', 1);
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains('clipboardHistory')) {
                    db.createObjectStore('clipboardHistory', { keyPath: 'id', autoIncrement: true });
                }
            };
            
            request.onsuccess = (event) => {
                const db = event.target.result;
                const transaction = db.transaction('clipboardHistory', 'readwrite');
                const store = transaction.objectStore('clipboardHistory');
                
                const addRequest = store.add({
                    ...data,
                    id: Date.now()
                });
                
                addRequest.onsuccess = () => resolve();
                addRequest.onerror = () => reject(addRequest.error);
            };
            
            request.onerror = () => reject(request.error);
        });
    }

    async notifyContentScript(text, processed) {
        // 使用MessagePort进行更高效的通信
        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
        if (tab) {
            try {
                // 建立长连接
                if (!this.port) {
                    this.port = chrome.tabs.connect(tab.id, { name: 'clipboard-monitor' });
                }
                
                this.port.postMessage({
                    action: 'clipboardChanged',
                    content: text,
                    processed: processed
                });
            } catch (error) {
                // 回退到传统消息传递
                await chrome.tabs.sendMessage(tab.id, {
                    action: 'clipboardChanged',
                    content: text,
                    processed: processed
                });
            }
        }
    }

    async toggleMonitoring() {
        this.isMonitoring = !this.isMonitoring;
        
        // 保存状态
        await chrome.storage.local.set({ clipboardMonitoring: this.isMonitoring });
        
        // 通知用户
        const message = this.isMonitoring ? '剪贴板监控已开启' : '剪贴板监控已关闭';
        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
        if (tab) {
            try {
                await chrome.tabs.sendMessage(tab.id, {
                    action: 'showNotification',
                    message: message,
                    type: this.isMonitoring ? 'success' : 'info'
                });
            } catch (error) {
                logger.warn('通知内容脚本失败:', error);
            }
        }
        
        return this.isMonitoring;
    }
}
```

### 2.2 智能文本处理系统

#### 2.2.1 功能描述

智能文本处理系统提供多种文本分析和处理功能，包括文本提取、链接检测、路径转换、代码命名拆分等。

#### 2.2.2 实现原理

- **多格式检测**：使用正则表达式和模式匹配检测不同类型的内容
- **智能拆分**：根据内容类型自动选择最适合的拆分规则
- **内容转换**：在不同格式之间进行转换，如路径格式转换
- **语义分析**：识别代码命名约定和文本结构

#### 2.2.3 关键代码

```javascript
// 智能文本拆分
export function splitText(text, delimiter = 'en-sentence') {
    if (!text || !text.trim()) return [];
    
    // 支持多规则同时应用
    const delimiters = Array.isArray(delimiter) ? delimiter : [delimiter];
    let results = [text.trim()];
    
    // 按优先级依次应用分隔规则
    for (const rule of delimiters) {
        const newResults = [];
        for (const segment of results) {
            newResults.push(...applySingleSplitRule(segment, rule));
        }
        results = newResults;
    }
    
    // 后处理：去重、过滤、长度校准
    return postProcessSplitResults(results);
}

// 多格式分析
export function analyzeTextForMultipleFormats(text) {
    const results = [];
    
    if (!text || !text.trim()) return results;

    // 路径检测和转换
    const pathResults = processPath(text);
    if