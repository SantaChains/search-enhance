# Decide search 扩展实现文档

## 1. 项目概述

Decide search（Search Buddy）是一款强大的浏览器扩展，通过智能文本处理、多格式分析和高级剪贴板监控增强用户的搜索体验。

### 1.1 核心功能

- **智能剪贴板监控**：实时监控剪贴板内容变化，自动记录到历史
- **多格式文本分析**：检测和处理URL、文件路径、邮箱、电话号码等多种格式
- **智能文本拆分**：支持多种分隔规则和内容类型识别
- **搜索引擎集成**：内置多种搜索引擎，支持快速切换
- **链接历史管理**：记录和管理访问过的链接，支持导出和清空
- **仓库链接生成**：从GitHub仓库格式生成多种平台链接
- **路径转换工具**：在不同路径格式之间转换
- **响应式界面**：适配不同屏幕尺寸和布局

### 1.2 技术架构

- **Manifest V3**：使用最新的Chrome扩展开发标准
- **模块化设计**：清晰的代码组织结构
- **后台脚本**：处理上下文菜单和键盘快捷键
- **内容脚本**：处理页面级交互和通知
- **弹出窗口/侧边栏**：提供用户界面
- **工具库**：封装通用功能和逻辑

### 1.3 技术迭代方向

| 现有技术 | 迭代技术 | 优势 | 应用场景 |
| :--- | :--- | :--- | :--- |
| 定期检查剪贴板 | Clipboard API + 事件监听 + Service Worker | 实时响应，性能更好，后台持续监控 | 剪贴板监控 |
| 正则表达式文本处理 | WebAssembly 分词库 + Web Workers | 速度更快，精度更高，不阻塞主线程 | 中文分词 |
| chrome.storage.local | IndexedDB + Cache API + 索引优化 | 存储容量更大，查询更快，性能更好 | 历史记录管理 |
| 原生HTML/CSS/JS | Web Components + 现代CSS + Shadow DOM | 组件化，样式隔离，维护性更好 | 界面实现 |
| 消息传递 | MessagePort 长连接 + 结构化克隆 | 减少通信开销，支持复杂数据传输 | 组件间通信 |
| 主线程处理 | Web Workers + 任务队列 | 避免阻塞主线程，响应更快，任务管理更高效 | 耗时操作 |
| 基础错误处理 | 完整的错误边界 + 错误监控 | 更可靠，用户体验更好，问题定位更准确 | 稳定性 |
| 模块化设计 | 插件架构 + ES模块 | 支持第三方扩展，代码组织更清晰 | 功能扩展 |
| 权限管理 | navigator.permissions API + 权限请求优化 | 更好的用户体验，权限控制更精细 | 安全性 |
| 响应式设计 | CSS Grid + Flexbox + 容器查询 | 适配更精准，布局更灵活 | 界面适配 |
| 后台脚本 | Service Worker + 事件驱动 | 更高效的后台处理，支持离线功能 | 后台任务 |
| 数据存储 | 分层存储策略（内存 + 缓存 + 持久化） | 性能与容量平衡，访问速度优化 | 数据管理 |

## 2. 核心功能实现

### 2.1 剪贴板监控系统

#### 2.1.1 功能描述

剪贴板监控系统实时检测剪贴板内容变化，自动记录到历史，并在内容变化时通知用户。支持通过快捷键（Alt+K）和侧边栏开关控制。

#### 2.1.2 实现原理

- **后台监控**：通过`chrome.storage.local`存储监控状态
- **内容脚本通知**：当剪贴板内容变化时，通过消息传递通知内容脚本显示页面通知
- **防抖处理**：使用防抖技术减少频繁的剪贴板检查和通知
- **安全处理**：对大内容进行截断处理，确保性能和稳定性

#### 2.1.3 关键代码

```javascript
// 剪贴板监控类
class ClipboardMonitor {
    constructor() {
        this.isMonitoring = false;
        this.init();
    }

    async init() {
        await this.initializeMonitoringState();
    }

    async handleNewClipboardContent(content) {
        // 安全处理：检查内容长度
        if (content.length > 10000) {
            content = content.substring(0, 100) + '...';
        }
        // 显示通知
        showPageNotification('检测到剪贴板内容变化', 'info');
    }
}

// 检查剪贴板内容
async function checkClipboard() {
    try {
        const text = await readFromClipboard();
        if (!text || text === lastClipboardContent) {
            return; // 内容未变化
        }
        lastClipboardContent = text;
        
        // 防抖处理
        if (clipboardDebounceTimer) {
            clearTimeout(clipboardDebounceTimer);
        }
        
        clipboardDebounceTimer = setTimeout(async () => {
            // 处理剪贴板内容
            await chrome.storage.local.set({
                lastClipboardContent: text,
                clipboardHistoryUpdated: timestamp
            });
            // 添加到剪贴板历史
            await addToClipboardHistory(text, 'clipboard-monitor');
        }, 100);
    } catch (error) {
        logger.error('读取剪贴板失败:', error);
    }
}
```

#### 2.1.4 迭代改进方案

**技术升级**：使用现代Clipboard API的`clipboardchange`事件（如果浏览器支持），结合Service Worker实现更高效的监控，同时添加权限管理和错误监控。

**关键代码改进**：

```javascript
// 现代剪贴板监控实现（增强版）
class EnhancedClipboardMonitor {
    constructor() {
        this.isMonitoring = false;
        this.port = null;
        this.worker = null;
        this.db = null;
        this.init();
    }

    async init() {
        await this.initializeMonitoringState();
        await this.setupDatabase();
        this.setupEventListeners();
        this.setupServiceWorker();
    }

    async setupDatabase() {
        // 初始化IndexedDB，添加索引优化
        return new Promise((resolve, reject) => {
            const request = indexedDB.open('EnhancedClipboardStore', 2);
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                
                // 创建对象存储和索引
                if (!db.objectStoreNames.contains('clipboardHistory')) {
                    const store = db.createObjectStore('clipboardHistory', { keyPath: 'id', autoIncrement: true });
                    store.createIndex('timestamp', 'timestamp', { unique: false });
                    store.createIndex('contentHash', 'contentHash', { unique: false });
                    store.createIndex('type', 'type', { unique: false });
                }
            };
            
            request.onsuccess = (event) => {
                this.db = event.target.result;
                resolve();
            };
            
            request.onerror = () => {
                logger.error('IndexedDB初始化失败:', request.error);
                reject(request.error);
            };
        });
    }

    setupEventListeners() {
        // 尝试使用Clipboard API的事件监听（现代浏览器）
        if (navigator.clipboard && navigator.clipboard.addEventListener) {
            try {
                navigator.clipboard.addEventListener('clipboardchange', async () => {
                    if (this.isMonitoring) {
                        await this.handleClipboardChange();
                    }
                });
                logger.info('使用现代Clipboard API事件监听');
            } catch (error) {
                // 回退到轮询方式
                this.setupPolling();
                logger.warn('Clipboard API事件监听失败，回退到轮询方式:', error);
            }
        } else {
            // 回退到轮询方式
            this.setupPolling();
            logger.info('使用轮询方式监控剪贴板');
        }

        // 权限变化监听
        if (navigator.permissions) {
            navigator.permissions.query({ name: 'clipboard-read' }).then(permissionStatus => {
                permissionStatus.addEventListener('change', () => {
                    logger.info('剪贴板权限变化:', permissionStatus.state);
                    if (permissionStatus.state === 'denied' && this.isMonitoring) {
                        this.notifyPermissionDenied();
                    }
                });
            });
        }
    }

    setupPolling() {
        // 使用requestAnimationFrame优化轮询
        let lastCheckTime = 0;
        const CHECK_INTERVAL = 1000; // 1秒检查一次

        const checkClipboard = async (timestamp) => {
            if (timestamp - lastCheckTime > CHECK_INTERVAL && this.isMonitoring) {
                lastCheckTime = timestamp;
                await this.handleClipboardChange();
            }
            if (this.isMonitoring) {
                requestAnimationFrame(checkClipboard);
            }
        };

        requestAnimationFrame(checkClipboard);
    }

    async setupServiceWorker() {
        // 注册Service Worker用于后台监控
        if ('serviceWorker' in navigator) {
            try {
                const registration = await navigator.serviceWorker.register('sw.js');
                logger.info('Service Worker注册成功:', registration);
                
                // 建立Service Worker通信
                registration.addEventListener('updatefound', () => {
                    const newWorker = registration.installing;
                    if (newWorker) {
                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'activated') {
                                logger.info('Service Worker激活成功');
                            }
                        });
                    }
                });
            } catch (error) {
                logger.warn('Service Worker注册失败:', error);
            }
        }
    }

    async handleClipboardChange() {
        try {
            // 检查权限
            if (!await this.checkClipboardPermission()) {
                return;
            }

            const text = await navigator.clipboard.readText();
            if (!text || text === this.lastContent) {
                return;
            }

            this.lastContent = text;
            
            // 处理剪贴板内容（使用Web Worker）
            const processed = await this.processContent(text);
            
            // 保存到存储
            await this.saveToStorage(text, processed);
            
            // 通知内容脚本
            await this.notifyContentScript(text, processed);
        } catch (error) {
            logger.error('处理剪贴板变化失败:', error);
            // 错误监控和上报
            this.reportError(error, 'clipboard-handling');
        }
    }

    async checkClipboardPermission() {
        // 检查剪贴板权限
        if (navigator.permissions) {
            const permission = await navigator.permissions.query({ name: 'clipboard-read' });
            return permission.state === 'granted';
        }
        // 回退：尝试访问剪贴板
        try {
            await navigator.clipboard.readText();
            return true;
        } catch {
            return false;
        }
    }

    async processContent(text) {
        // 使用Web Worker处理耗时的内容分析
        return new Promise((resolve) => {
            if (!this.worker) {
                this.worker = new Worker('src/workers/contentProcessor.js', { type: 'module' });
            }

            this.worker.onmessage = (e) => {
                resolve(e.data);
            };

            this.worker.onerror = (error) => {
                logger.error('Worker错误:', error);
                resolve([]);
            };

            this.worker.postMessage({ action: 'process', text });
        });
    }

    async saveToStorage(text, processed) {
        // 计算内容哈希用于去重
        const contentHash = await this.calculateHash(text);
        
        // 使用IndexedDB存储
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction('clipboardHistory', 'readwrite');
            const store = transaction.objectStore('clipboardHistory');
            
            const clipboardItem = {
                content: text,
                contentHash: contentHash,
                processed: processed,
                timestamp: Date.now(),
                type: this.detectContentType(text),
                size: text.length
            };
            
            const addRequest = store.add(clipboardItem);
            
            addRequest.onsuccess = () => {
                // 清理旧数据，保持存储大小合理
                this.cleanupOldData();
                resolve();
            };
            
            addRequest.onerror = () => {
                logger.error('保存剪贴板数据失败:', addRequest.error);
                reject(addRequest.error);
            };
        });
    }

    async notifyContentScript(text, processed) {
        // 使用MessagePort进行更高效的通信
        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
        if (tab) {
            try {
                // 建立长连接
                if (!this.port) {
                    this.port = chrome.tabs.connect(tab.id, { name: 'enhanced-clipboard-monitor' });
                    
                    // 处理连接错误
                    this.port.onDisconnect.addListener(() => {
                        this.port = null;
                    });
                }
                
                // 使用结构化克隆传递复杂数据
                this.port.postMessage({
                    action: 'clipboardChanged',
                    content: text,
                    processed: processed,
                    timestamp: Date.now()
                });
            } catch (error) {
                // 回退到传统消息传递
                await chrome.tabs.sendMessage(tab.id, {
                    action: 'clipboardChanged',
                    content: text,
                    processed: processed
                });
            }
        }
    }

    async toggleMonitoring() {
        this.isMonitoring = !this.isMonitoring;
        
        // 保存状态
        await chrome.storage.local.set({ clipboardMonitoring: this.isMonitoring });
        
        // 通知用户
        const message = this.isMonitoring ? '剪贴板监控已开启' : '剪贴板监控已关闭';
        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
        if (tab) {
            try {
                await chrome.tabs.sendMessage(tab.id, {
                    action: 'showNotification',
                    message: message,
                    type: this.isMonitoring ? 'success' : 'info'
                });
            } catch (error) {
                logger.warn('通知内容脚本失败:', error);
            }
        }
        
        return this.isMonitoring;
    }

    async calculateHash(text) {
        // 计算内容哈希用于去重
        const encoder = new TextEncoder();
        const data = encoder.encode(text);
        const hashBuffer = await crypto.subtle.digest('SHA-256', data);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    detectContentType(text) {
        // 检测内容类型
        if (text.startsWith('http://') || text.startsWith('https://')) {
            return 'url';
        }
        if (text.includes('@') && text.includes('.')) {
            return 'email';
        }
        if (/^\d{11}$/.test(text)) {
            return 'phone';
        }
        if (text.length > 500) {
            return 'large';
        }
        return 'text';
    }

    cleanupOldData() {
        // 清理旧数据，保持存储大小合理
        const transaction = this.db.transaction('clipboardHistory', 'readwrite');
        const store = transaction.objectStore('clipboardHistory');
        const index = store.index('timestamp');
        
        // 删除30天前的数据
        const cutoffTime = Date.now() - 30 * 24 * 60 * 60 * 1000;
        const range = IDBKeyRange.upperBound(cutoffTime);
        
        index.openCursor(range).onsuccess = (event) => {
            const cursor = event.target.result;
            if (cursor) {
                cursor.delete();
                cursor.continue();
            }
        };
    }

    notifyPermissionDenied() {
        // 通知用户权限被拒绝
        chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
            if (tabs[0]) {
                chrome.tabs.sendMessage(tabs[0].id, {
                    action: 'showNotification',
                    message: '剪贴板权限被拒绝，请在浏览器设置中允许权限',
                    type: 'error'
                });
            }
        });
    }

    reportError(error, context) {
        // 错误监控和上报
        chrome.runtime.sendMessage({
            action: 'reportError',
            error: {
                message: error.message,
                stack: error.stack,
                context: context
            },
            timestamp: Date.now()
        });
    }
}

// 导出单例
const clipboardMonitor = new EnhancedClipboardMonitor();
export default clipboardMonitor;
```

### 2.2 智能文本处理系统

#### 2.2.1 功能描述

智能文本处理系统提供多种文本分析和处理功能，包括文本提取、链接检测、路径转换、代码命名拆分等。

#### 2.2.2 实现原理

- **多格式检测**：使用正则表达式和模式匹配检测不同类型的内容
- **智能拆分**：根据内容类型自动选择最适合的拆分规则
- **内容转换**：在不同格式之间进行转换，如路径格式转换
- **语义分析**：识别代码命名约定和文本结构

#### 2.2.3 关键代码

```javascript
// 智能文本拆分
export function splitText(text, delimiter = 'en-sentence') {
    if (!text || !text.trim()) return [];
    
    // 支持多规则同时应用
    const delimiters = Array.isArray(delimiter) ? delimiter : [delimiter];
    let results = [text.trim()];
    
    // 按优先级依次应用分隔规则
    for (const rule of delimiters) {
        const newResults = [];
        for (const segment of results) {
            newResults.push(...applySingleSplitRule(segment, rule));
        }
        results = newResults;
    }
    
    // 后处理：去重、过滤、长度校准
    return postProcessSplitResults(results);
}

// 多格式分析
export function analyzeTextForMultipleFormats(text) {
    const results = [];
    
    if (!text || !text.trim()) return results;

    // 路径检测和转换
    const pathResults = processPath(text);
    if (pathResults) {
        results.push({
            type: '路径转换',
            data: pathResults
        });
    }

    // URL提取
    const { extractedLinks } = processTextExtraction(text);
    if (extractedLinks.length > 0) {
        results.push({
            type: '链接提取',
            data: extractedLinks.map(url => ({ url }))
        });
    }

    // 仓库链接生成
    const repoResult = processLinkGeneration(text);
    if (repoResult) {
        results.push({
            type: '仓库链接',
            data: repoResult.generatedLinks.map(url => ({ url }))
        });
    }

    return results;
}
```

#### 2.2.4 迭代改进方案

**技术升级**：使用WebAssembly优化的分词库，结合AI-powered的文本分析API，提高处理速度和准确性。

**关键代码改进**：

```javascript
// WebAssembly优化的文本处理系统
class WasmTextProcessor {
    constructor() {
        this.loaded = false;
        this.wasmModule = null;
        this.init();
    }

    async init() {
        try {
            // 加载WebAssembly模块
            this.wasmModule = await this.loadWasmModule();
            this.loaded = true;
            logger.info('WebAssembly文本处理模块加载成功');
        } catch (error) {
            logger.error('WebAssembly模块加载失败:', error);
            // 回退到JavaScript实现
            this.loaded = false;
        }
    }

    async loadWasmModule() {
        // 加载编译为WebAssembly的Jieba分词库
        const response = await fetch('src/utils/wasm/jieba.wasm');
        const buffer = await response.arrayBuffer();
        const module = await WebAssembly.instantiate(buffer);
        return module.instance.exports;
    }

    async splitText(text, options = {}) {
        if (!text || !text.trim()) return [];

        if (this.loaded && this.wasmModule) {
            // 使用WebAssembly进行分词
            return await this.wasmSplitText(text, options);
        } else {
            // 回退到JavaScript实现
            return this.jsSplitText(text, options);
        }
    }

    async wasmSplitText(text, options) {
        // WebAssembly分词实现
        return new Promise((resolve) => {
            // 调用WebAssembly函数
            const resultPtr = this.wasmModule.splitText(
                this.stringToWasmMemory(text),
                text.length,
                options.mode || 0 // 0: 精确模式, 1: 全模式, 2: 搜索引擎模式
            );

            // 从WebAssembly内存中读取结果
            const result = this.readStringFromWasmMemory(resultPtr);
            resolve(JSON.parse(result));
        });
    }

    jsSplitText(text, options) {
        // 现有的JavaScript实现
        const delimiter = options.delimiter || 'en-sentence';
        const delimiters = Array.isArray(delimiter) ? delimiter : [delimiter];
        let results = [text.trim()];
        
        for (const rule of delimiters) {
            const newResults = [];
            for (const segment of results) {
                newResults.push(...this.applySingleSplitRule(segment, rule));
            }
            results = newResults;
        }
        
        return this.postProcessSplitResults(results);
    }

    async analyzeTextForMultipleFormats(text) {
        if (!text || !text.trim()) return [];

        // 使用Web Worker处理多格式分析
        return new Promise((resolve) => {
            const worker = new Worker('src/workers/textAnalyzer.js');
            
            worker.onmessage = (e) => {
                resolve(e.data);
                worker.terminate();
            };
            
            worker.onerror = (error) => {
                logger.error('文本分析Worker错误:', error);
                resolve([]);
                worker.terminate();
            };
            
            worker.postMessage({ action: 'analyze', text });
        });
    }

    // WebAssembly内存操作辅助方法
    stringToWasmMemory(str) {
        // 实现字符串到WebAssembly内存的转换
        // ...
    }

    readStringFromWasmMemory(ptr) {
        // 实现从WebAssembly内存读取字符串
        // ...
    }
}

// 导出单例
const textProcessor = new WasmTextProcessor();
export default textProcessor;
```

### 2.3 链接历史管理

#### 2.3.1 功能描述

链接历史管理系统记录用户访问过的链接，支持分类、搜索、导出和清空操作。特别增强了GitHub仓库的检测和管理。

#### 2.3.2 实现原理

- **增强的历史记录**：记录链接的元数据，如域名、类型、GitHub仓库信息等
- **去重处理**：自动移除重复的链接记录
- **历史限制**：支持设置历史记录数量限制
- **导出功能**：支持将历史记录导出为JSON文件

#### 2.3.3 关键代码

```javascript
// 添加到历史记录
export async function addToHistory(item) {
    try {
        if (!item || typeof item !== 'string' || !item.trim()) {
            logger.warn('Invalid history item provided');
            return false;
        }
        
        const { history, historyLimit } = await getSettings();
        const trimmedItem = item.trim();
        
        // 增强的历史记录条目
        const historyEntry = createHistoryEntry(trimmedItem);
        
        // 移除重复项并添加到前面
        const filteredHistory = history.filter(h => {
            const existing = typeof h === 'string' ? h : h.url;
            return existing !== historyEntry.url;
        });
        const newHistory = [historyEntry, ...filteredHistory];
        
        // 应用历史限制
        if (newHistory.length > historyLimit) {
            newHistory.length = historyLimit;
        }
        
        const success = await saveSettings({ history: newHistory });
        return success;
    } catch (error) {
        logger.error('Failed to add to history:', error);
        return false;
    }
}

// 创建增强的历史记录条目
export function createHistoryEntry(url) {
    const entry = {
        url,
        timestamp: new Date().toISOString(),
        type: 'other',
        domain: '',
        title: '',
        isGitHubRepo: false,
        repoInfo: null
    };
    
    try {
        const urlObj = new URL(url);
        entry.domain = urlObj.hostname;
        
        // GitHub仓库检测
        if (urlObj.hostname === 'github.com') {
            const pathParts = urlObj.pathname.split('/').filter(Boolean);
            if (pathParts.length >= 2) {
                entry.type = 'github';
                entry.isGitHubRepo = true;
                entry.repoInfo = {
                    username: pathParts[0],
                    repository: pathParts[1],
                    fullName: `${pathParts[0]}/${pathParts[1]}`
                };
                entry.title = entry.repoInfo.fullName;
            }
        }
    } catch (e) {
        // 非有效URL，视为搜索查询
        entry.type = 'search';
        entry.title = url.length > 30 ? url.substring(0, 30) + '...' : url;
    }
    
    return entry;
}
```

#### 2.3.4 迭代改进方案

**技术升级**：使用IndexedDB存储大量历史记录，结合Cache API进行缓存，提高性能和存储容量。

**关键代码改进**：

```javascript
// 增强的历史记录管理类
class EnhancedHistoryManager {
    constructor() {
        this.dbName = 'SearchBuddyHistory';
        this.dbVersion = 2;
        this.init();
    }

    async init() {
        await this.openDatabase();
        await this.migrateDatabase();
    }

    async openDatabase() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.dbVersion);

            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                
                // 创建历史记录存储
                if (!db.objectStoreNames.contains('history')) {
                    const historyStore = db.createObjectStore('history', { keyPath: 'id', autoIncrement: true });
                    historyStore.createIndex('timestamp', 'timestamp', { unique: false });
                    historyStore.createIndex('domain', 'domain', { unique: false });
                    historyStore.createIndex('type', 'type', { unique: false });
                }

                // 创建缓存存储
                if (!db.objectStoreNames.contains('cache')) {
                    db.createObjectStore('cache', { keyPath: 'key' });
                }
            };

            request.onsuccess = (event) => {
                this.db = event.target.result;
                resolve();
            };

            request.onerror = (event) => {
                reject(event.target.error);
            };
        });
    }

    async migrateDatabase() {
        // 从chrome.storage迁移到IndexedDB
        try {
            const { history } = await chrome.storage.local.get('history');
            if (history && history.length > 0) {
                await this.bulkAddHistory(history);
                // 迁移完成后清理chrome.storage
                await chrome.storage.local.remove('history');
                logger.info('历史记录迁移完成');
            }
        } catch (error) {
            logger.error('历史记录迁移失败:', error);
        }
    }

    async addHistory(item) {
        if (!item || typeof item !== 'string' || !item.trim()) {
            logger.warn('无效的历史记录项');
            return false;
        }

        const trimmedItem = item.trim();
        const historyEntry = this.createHistoryEntry(trimmedItem);

        try {
            // 检查是否已存在
            const exists = await this.historyExists(historyEntry.url);
            if (exists) {
                // 更新现有记录
                await this.updateHistory(historyEntry);
            } else {
                // 添加新记录
                await this.addHistoryEntry(historyEntry);
            }

            // 应用历史限制
            await this.applyHistoryLimit();

            return true;
        } catch (error) {
            logger.error('添加历史记录失败:', error);
            return false;
        }
    }

    async addHistoryEntry(entry) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction('history', 'readwrite');
            const store = transaction.objectStore('history');
            
            const request = store.add({
                ...entry,
                id: Date.now(),
                createdAt: new Date().toISOString()
            });

            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    }

    async historyExists(url) {
        return new Promise((resolve) => {
            const transaction = this.db.transaction('history', 'readonly');
            const store = transaction.objectStore('history');
            
            const index = store.index('url');
            const request = index.get(url);

            request.onsuccess = () => resolve(request.result !== undefined);
            request.onerror = () => resolve(false);
        });
    }

    async updateHistory(entry) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction('history', 'readwrite');
            const store = transaction.objectStore('history');
            
            const index = store.index('url');
            const request = index.get(entry.url);

            request.onsuccess = () => {
                if (request.result) {
                    const existingEntry = request.result;
                    const updatedEntry = {
                        ...existingEntry,
                        ...entry,
                        updatedAt: new Date().toISOString()
                    };
                    
                    const updateRequest = store.put(updatedEntry);
                    updateRequest.onsuccess = () => resolve();
                    updateRequest.onerror = () => reject(updateRequest.error);
                } else {
                    resolve();
                }
            };

            request.onerror = () => reject(request.error);
        });
    }

    async applyHistoryLimit() {
        const { historyLimit } = await getSettings();
        
        // 获取历史记录数量
        const count = await this.getHistoryCount();
        
        if (count > historyLimit) {
            // 删除最旧的记录
            const toDelete = count - historyLimit;
            await this.deleteOldestHistory(toDelete);
        }
    }

    async getHistoryCount() {
        return new Promise((resolve) => {
            const transaction = this.db.transaction('history', 'readonly');
            const store = transaction.objectStore('history');
            
            const request = store.count();
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => resolve(0);
        });
    }

    async deleteOldestHistory(count) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction('history', 'readwrite');
            const store = transaction.objectStore('history');
            const index = store.index('timestamp');
            
            const request = index.openCursor();
            let deleted = 0;

            request.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor && deleted < count) {
                    cursor.delete();
                    deleted++;
                    cursor.continue();
                } else {
                    resolve();
                }
            };

            request.onerror = () => reject(request.error);
        });
    }

    async getHistory(options = {}) {
        const { limit = 100, offset = 0, type = 'all' } = options;
        
        return new Promise((resolve) => {
            const transaction = this.db.transaction('history', 'readonly');
            const store = transaction.objectStore('history');
            const index = store.index('timestamp');
            
            const request = index.openCursor(null, 'prev'); // 按时间戳降序
            const results = [];
            let processed = 0;

            request.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor && processed < limit + offset) {
                    if (processed >= offset) {
                        if (type === 'all' || cursor.value.type === type) {
                            results.push(cursor.value);
                        }
                    }
                    processed++;
                    cursor.continue();
                } else {
                    resolve(results);
                }
            };

            request.onerror = () => resolve([]);
        });
    }

    async clearHistory() {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction('history', 'readwrite');
            const store = transaction.objectStore('history');
            
            const request = store.clear();
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    }

    createHistoryEntry(url) {
        // 现有的createHistoryEntry实现
        const entry = {
            url,
            timestamp: new Date().toISOString(),
            type: 'other',
            domain: '',
            title: '',
            isGitHubRepo: false,
            repoInfo: null
        };
        
        try {
            const urlObj = new URL(url);
            entry.domain = urlObj.hostname;
            
            if (urlObj.hostname === 'github.com') {
                const pathParts = urlObj.pathname.split('/').filter(Boolean);
                if (pathParts.length >= 2) {
                    entry.type = 'github';
                    entry.isGitHubRepo = true;
                    entry.repoInfo = {
                        username: pathParts[0],
                        repository: pathParts[1],
                        fullName: `${pathParts[0]}/${pathParts[1]}`
                    };
                    entry.title = entry.repoInfo.fullName;
                }
            }
        } catch (e) {
            entry.type = 'search';
            entry.title = url.length > 30 ? url.substring(0, 30) + '...' : url;
        }
        
        return entry;
    }
}

// 导出单例
const historyManager = new EnhancedHistoryManager();
export default historyManager;
```

### 2.4 剪贴板历史管理

#### 2.4.1 功能描述

剪贴板历史管理系统记录用户复制的内容，支持查看、编辑、恢复和批量操作。

#### 2.4.2 实现原理

- **增强的剪贴板记录**：记录复制内容的来源、时间戳等元数据
- **编辑功能**：支持编辑剪贴板历史中的内容
- **恢复功能**：支持恢复编辑过的内容到原始状态
- **批量操作**：支持批量选择和删除剪贴板历史项

#### 2.4.3 关键代码

```javascript
// 添加到剪贴板历史
export async function addToClipboardHistory(content, source = 'clipboard') {
    try {
        if (!content || !content.trim()) {
            logger.warn('Invalid clipboard content provided');
            return false;
        }
        
        const { clipboardHistory, clipboardHistoryLimit } = await getSettings();
        const trimmedContent = content.trim();
        
        // 创建剪贴板历史条目
        const entry = {
            id: Date.now().toString(),
            content: trimmedContent,
            source,
            timestamp: new Date().toISOString(),
            isEdited: false,
            originalContent: trimmedContent
        };
        
        // 移除重复内容
        const filteredHistory = clipboardHistory.filter(item => item.content !== trimmedContent);
        
        // 添加新条目到前面
        const newHistory = [entry, ...filteredHistory];
        
        // 应用历史限制
        if (newHistory.length > clipboardHistoryLimit) {
            newHistory.length = clipboardHistoryLimit;
        }
        
        const success = await saveSettings({ clipboardHistory: newHistory });
        return success;
    } catch (error) {
        logger.error('Failed to add to clipboard history:', error);
        return false;
    }
}

// 更新剪贴板历史项
export async function updateClipboardHistoryItem(id, newContent) {
    try {
        const { clipboardHistory } = await getSettings();
        const updatedHistory = clipboardHistory.map(item => {
            if (item.id === id) {
                return {
                    ...item,
                    content: newContent.trim(),
                    isEdited: true,
                    editedAt: new Date().toISOString()
                };
            }
            return item;
        });
        
        const success = await saveSettings({ clipboardHistory: updatedHistory });
        return success;
    } catch (error) {
        logger.error('Failed to update clipboard history item:', error);
        return false;
    }
}
```

#### 2.4.4 迭代改进方案

**技术升级**：使用IndexedDB存储剪贴板历史，结合Web Workers处理批量操作，提高性能和可靠性。

**关键代码改进**：

```javascript
// 增强的剪贴板历史管理类
class EnhancedClipboardHistory {
    constructor() {
        this.dbName = 'SearchBuddyClipboard';
        this.dbVersion = 1;
        this.init();
    }

    async init() {
        await this.openDatabase();
    }

    async openDatabase() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.dbVersion);

            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                
                if (!db.objectStoreNames.contains('clipboardHistory')) {
                    const store = db.createObjectStore('clipboardHistory', { keyPath: 'id' });
                    store.createIndex('timestamp', 'timestamp', { unique: false });
                    store.createIndex('source', 'source', { unique: false });
                }
            };

            request.onsuccess = (event) => {
                this.db = event.target.result;
                resolve();
            };

            request.onerror = (event) => {
                reject(event.target.error);
            };
        });
    }

    async addToHistory(content, source = 'clipboard') {
        if (!content || !content.trim()) {
            logger.warn('无效的剪贴板内容');
            return false;
        }

        const trimmedContent = content.trim();
        const entry = {
            id: Date.now().toString(),
            content: trimmedContent,
            source,
            timestamp: new Date().toISOString(),
            isEdited: false,
            originalContent: trimmedContent
        };

        try {
            // 检查是否重复
            const isDuplicate = await this.isDuplicateContent(trimmedContent);
            if (isDuplicate) {
                return true; // 已存在，不需要添加
            }

            // 添加到数据库
            await this.addEntry(entry);

            // 应用历史限制
            await this.applyHistoryLimit();

            return true;
        } catch (error) {
            logger.error('添加剪贴板历史失败:', error);
            return false;
        }
    }

    async isDuplicateContent(content) {
        return new Promise((resolve) => {
            const transaction = this.db.transaction('clipboardHistory', 'readonly');
            const store = transaction.objectStore('clipboardHistory');
            
            const request = store.openCursor();
            let found = false;

            request.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor) {
                    if (cursor.value.content === content) {
                        found = true;
                    } else {
                        cursor.continue();
                    }
                } else {
                    resolve(found);
                }
            };

            request.onerror = () => resolve(false);
        });
    }

    async addEntry(entry) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction('clipboardHistory', 'readwrite');
            const store = transaction.objectStore('clipboardHistory');
            
            const request = store.add(entry);
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    }

    async applyHistoryLimit() {
        const { clipboardHistoryLimit } = await getSettings();
        
        const count = await this.getHistoryCount();
        
        if (count > clipboardHistoryLimit) {
            const toDelete = count - clipboardHistoryLimit;
            await this.deleteOldestEntries(toDelete);
        }
    }

    async getHistoryCount() {
        return new Promise((resolve) => {
            const transaction = this.db.transaction('clipboardHistory', 'readonly');
            const store = transaction.objectStore('clipboardHistory');
            
            const request = store.count();
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => resolve(0);
        });
    }

    async deleteOldestEntries(count) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction('clipboardHistory', 'readwrite');
            const store = transaction.objectStore('clipboardHistory');
            const index = store.index('timestamp');
            
            const request = index.openCursor();
            let deleted = 0;

            request.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor && deleted < count) {
                    cursor.delete();
                    deleted++;
                    cursor.continue();
                } else {
                    resolve();
                }
            };

            request.onerror = () => reject(request.error);
        });
    }

    async getHistory(options = {}) {
        const { limit = 50, offset = 0 } = options;
        
        return new Promise((resolve) => {
            const transaction = this.db.transaction('clipboardHistory', 'readonly');
            const store = transaction.objectStore('clipboardHistory');
            const index = store.index('timestamp');
            
            const request = index.openCursor(null, 'prev'); // 按时间戳降序
            const results = [];
            let processed = 0;

            request.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor && processed < limit + offset) {
                    if (processed >= offset) {
                        results.push(cursor.value);
                    }
                    processed++;
                    cursor.continue();
                } else {
                    resolve(results);
                }
            };

            request.onerror = () => resolve([]);
        });
    }

    async updateItem(id, newContent) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction('clipboardHistory', 'readwrite');
            const store = transaction.objectStore('clipboardHistory');
            
            const request = store.get(id);

            request.onsuccess = () => {
                if (request.result) {
                    const entry = request.result;
                    const updatedEntry = {
                        ...entry,
                        content: newContent.trim(),
                        isEdited: true,
                        editedAt: new Date().toISOString()
                    };
                    
                    const updateRequest = store.put(updatedEntry);
                    updateRequest.onsuccess = () => resolve(true);
                    updateRequest.onerror = () => reject(updateRequest.error);
                } else {
                    resolve(false);
                }
            };

            request.onerror = () => reject(request.error);
        });
    }

    async deleteItem(id) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction('clipboardHistory', 'readwrite');
            const store = transaction.objectStore('clipboardHistory');
            
            const request = store.delete(id);
            request.onsuccess = () => resolve(true);
            request.onerror = () => resolve(false);
        });
    }

    async deleteMultipleItems(ids) {
        // 使用批量操作提高性能
        return new Promise((resolve) => {
            const transaction = this.db.transaction('clipboardHistory', 'readwrite');
            const store = transaction.objectStore('clipboardHistory');
            
            let completed = 0;
            let errors = 0;

            ids.forEach(id => {
                const request = store.delete(id);
                request.onsuccess = () => {
                    completed++;
                    if (completed + errors === ids.length) {
                        resolve(completed === ids.length);
                    }
                };
                request.onerror = () => {
                    errors++;
                    if (completed + errors === ids.length) {
                        resolve(completed === ids.length);
                    }
                };
            });
        });
    }

    async restoreItem(id) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction('clipboardHistory', 'readwrite');
            const store = transaction.objectStore('clipboardHistory');
            
            const request = store.get(id);

            request.onsuccess = () => {
                if (request.result && request.result.isEdited) {
                    const entry = request.result;
                    const restoredEntry = {
                        ...entry,
                        content: entry.originalContent,
                        isEdited: false,
                        editedAt: null
                    };
                    
                    const updateRequest = store.put(restoredEntry);
                    updateRequest.onsuccess = () => resolve(true);
                    updateRequest.onerror = () => reject(updateRequest.error);
                } else {
                    resolve(false);
                }
            };

            request.onerror = () => reject(request.error);
        });
    }

    async clearHistory() {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction('clipboardHistory', 'readwrite');
            const store = transaction.objectStore('clipboardHistory');
            
            const request = store.clear();
            request.onsuccess = () => resolve(true);
            request.onerror = () => resolve(false);
        });
    }
}

// 导出单例
const clipboardHistoryManager = new EnhancedClipboardHistory();
export default clipboardHistoryManager;
```

### 2.5 搜索引擎集成

#### 2.5.1 功能描述

搜索引擎集成系统内置多种搜索引擎，支持快速切换和自定义。

#### 2.5.2 实现原理

- **内置搜索引擎**：预配置多种常用搜索引擎
- **搜索引擎模板**：使用模板系统构建搜索URL
- **默认引擎设置**：支持设置默认搜索引擎

#### 2.5.3 关键代码

```javascript
// 默认设置与增强的搜索引擎
export const DEFAULTS = {
    searchEngines: [
        { name: 'Bing', template: 'https://www.bing.com/search?q=%s', category: 'general' },
        { name: 'Google', template: 'https://www.google.com/search?q=%s', category: 'general' },
        { name: 'Google Scholar', template: 'https://scholar.google.com/scholar?q=%s', category: 'academic' },
        { name: 'Metaso', template: 'https://metaso.cn/search?q=%s', category: 'ai' },
        { name: 'Sogou', template: 'https://www.sogou.com/web?query=%s', category: 'general' },
        { name: 'GitHub', template: 'https://github.com/search?q=%s', category: 'code' },
        { name: 'Stack Overflow', template: 'https://stackoverflow.com/search?q=%s', category: 'code' },
        { name: 'MDN', template: 'https://developer.mozilla.org/en-US/search?q=%s', category: 'docs' },
    ],
    // 其他默认设置...
};

// 搜索功能
function handleSearch() {
    const query = elements.search_input.value.trim();
    if (!query) return;

    if (isURL(query)) {
        window.open(query, '_blank');
        addToHistoryEnhanced(query);
        return;
    }
    
    let selectedEngineName = appState.settings.defaultEngine;
    if (elements.engine_select && elements.engine_select.value) {
        selectedEngineName = elements.engine_select.value;
    }
    
    const selectedEngine = appState.settings.searchEngines.find(e => e.name === selectedEngineName);
    
    if (selectedEngine) {
        const searchUrl = selectedEngine.template.replace('%s', encodeURIComponent(query));
        window.open(searchUrl, '_blank');
        addToHistoryEnhanced(query);
    }
}
```

#### 2.5.4 迭代改进方案

**技术升级**：使用Web Components构建搜索引擎选择器，支持动态添加和管理搜索引擎，结合AI推荐最适合的搜索引擎。

**关键代码改进**：

```javascript
// 搜索引擎管理类
class SearchEngineManager {
    constructor() {
        this.engines = [];
        this.defaultEngine = 'Bing';
        this.init();
    }

    async init() {
        await this.loadEngines();
        this.registerWebComponents();
    }

    async loadEngines() {
        const settings = await getSettings();
        this.engines = settings.searchEngines || this.getDefaultEngines();
        this.defaultEngine = settings.defaultEngine || 'Bing';
    }

    getDefaultEngines() {
        return [
            { name: 'Bing', template: 'https://www.bing.com/search?q=%s', category: 'general', icon: 'https://www.bing.com/favicon.ico' },
            { name: 'Google', template: 'https://www.google.com/search?q=%s', category: 'general', icon: 'https://www.google.com/favicon.ico' },
            { name: 'Google Scholar', template: 'https://scholar.google.com/scholar?q=%s', category: 'academic', icon: 'https://scholar.google.com/favicon.ico' },
            { name: 'Metaso', template: 'https://metaso.cn/search?q=%s', category: 'ai', icon: 'https://metaso.cn/favicon.ico' },
            { name: 'Sogou', template: 'https://www.sogou.com/web?query=%s', category: 'general', icon: 'https://www.sogou.com/favicon.ico' },
            { name: 'GitHub', template: 'https://github.com/search?q=%s', category: 'code', icon: 'https://github.com/favicon.ico' },
            { name: 'Stack Overflow', template: 'https://stackoverflow.com/search?q=%s', category: 'code', icon: 'https://stackoverflow.com/favicon.ico' },
            { name: 'MDN', template: 'https://developer.mozilla.org/en-US/search?q=%s', category: 'docs', icon: 'https://developer.mozilla.org/favicon.ico' },
        ];
    }

    registerWebComponents() {
        // 注册搜索引擎选择器组件
        customElements.define('search-engine-selector', class extends HTMLElement {
            constructor() {
                super();
                this.attachShadow({ mode: 'open' });
                this.render();
            }

            async connectedCallback() {
                await this.updateEngines();
                this.addEventListener('engine-selected', (e) => {
                    this.dispatchEvent(new CustomEvent('engine-change', {
                        bubbles: true,
                        detail: e.detail
                    }));
                });
            }

            async updateEngines() {
                const engines = await searchEngineManager.getEngines();
                const defaultEngine = await searchEngineManager.getDefaultEngine();
                this.render(engines, defaultEngine);
            }

            render(engines = [], defaultEngine = 'Bing') {
                this.shadowRoot.innerHTML = `
                    <style>
                        :host {
                            display: block;
                        }
                        .engine-selector {
                            display: flex;
                            flex-wrap: wrap;
                            gap: 8px;
                            margin: 8px 0;
                        }
                        .engine-button {
                            display: flex;
                            align-items: center;
                            gap: 6px;
                            padding: 6px 12px;
                            border: 1px solid #ddd;
                            border-radius: 16px;
                            background: white;
                            cursor: pointer;
                            transition: all 0.2s ease;
                        }
                        .engine-button:hover {
                            border-color: #0078d4;
                            background: #f0f7ff;
                        }
                        .engine-button.active {
                            border-color: #0078d4;
                            background: #0078d4;
                            color: white;
                        }
                        .engine-icon {
                            width: 16px;
                            height: 16px;
                            border-radius: 2px;
                        }
                        .custom-engine {
                            margin-top: 8px;
                            padding: 8px;
                            border: 1px dashed #ddd;
                            border-radius: 4px;
                        }
                        .custom-engine input {
                            margin: 4px 0;
                            padding: 4px 8px;
                            width: 100%;
                            box-sizing: border-box;
                        }
                    </style>
                    <div class="engine-selector">
                        ${engines.map(engine => `
                            <button class="engine-button ${engine.name === defaultEngine ? 'active' : ''}"
                                    data-engine="${engine.name}">
                                <img class="engine-icon" src="${engine.icon}" alt="${engine.name}">
                                <span>${engine.name}</span>
                            </button>
                        `).join('')}
                    </div>
                    <div class="custom-engine">
                        <h4>添加自定义搜索引擎</h4>
                        <input type="text" placeholder="搜索引擎名称" id="engine-name">
                        <input type="text" placeholder="搜索URL模板 (使用 %s 作为查询占位符)" id="engine-template">
                        <input type="text" placeholder="图标URL" id="engine-icon">
                        <button id="add-engine">添加</button>
                    </div>
                `;

                // 添加事件监听器
                this.shadowRoot.querySelectorAll('.engine-button').forEach(button => {
                    button.addEventListener('click', () => {
                        this.selectEngine(button.dataset.engine);
                    });
                });

                this.shadowRoot.getElementById('add-engine').addEventListener('click', () => {
                    this.addCustomEngine();
                });
            }

            selectEngine(engineName) {
                // 更新UI
                this.shadowRoot.querySelectorAll('.engine-button').forEach(button => {
                    button.classList.toggle('active', button.dataset.engine === engineName);
                });

                // 通知父组件
                this.dispatchEvent(new CustomEvent('engine-selected', {
                    bubbles: true,
                    detail: engineName
                }));

                // 保存默认引擎
                searchEngineManager.setDefaultEngine(engineName);
            }

            async addCustomEngine() {
                const name = this.shadowRoot.getElementById('engine-name').value;
                const template = this.shadowRoot.getElementById('engine-template').value;
                const icon = this.shadowRoot.getElementById('engine-icon').value;

                if (name && template) {
                    await searchEngineManager.addEngine({
                        name,
                        template,
                        category: 'custom',
                        icon: icon || 'https://www.google.com/s2/favicons?domain=' + new URL(template).hostname
                    });
                    await this.updateEngines();
                }
            }
        });
    }

    async getEngines() {
        await this.loadEngines();
        return this.engines;
    }

    async getDefaultEngine() {
        await this.loadEngines();
        return this.defaultEngine;
    }

    async setDefaultEngine(engineName) {
        this.defaultEngine = engineName;
        const settings = await getSettings();
        await saveSettings({ ...settings, defaultEngine: engineName });
    }

    async addEngine(engine) {
        this.engines.push(engine);
        const settings = await getSettings();
        await saveSettings({ ...settings, searchEngines: this.engines });
    }

    async removeEngine(engineName) {
        this.engines = this.engines.filter(engine => engine.name !== engineName);
        const settings = await getSettings();
        await saveSettings({ ...settings, searchEngines: this.engines });
    }

    async getSearchUrl(query, engineName = null) {
        const engine = this.engines.find(e => e.name === (engineName || this.defaultEngine));
        if (engine) {
            return engine.template.replace('%s', encodeURIComponent(query));
        }
        return null;
    }

    async suggestEngine(query) {
        // 基于查询内容推荐最适合的搜索引擎
        const categories = this.analyzeQuery(query);
        
        // 按分类匹配搜索引擎
        for (const category of categories) {
            const engine = this.engines.find(e => e.category === category);
            if (engine) {
                return engine.name;
            }
        }
        
        return this.defaultEngine;
    }

    analyzeQuery(query) {
        const categories = [];
        
        // 代码相关查询
        if (/\b(function|class|const|let|var|import|export|def|print|console\.log)\b/.test(query)) {
            categories.push('code');
        }
        
        // 学术相关查询
        if (/\b(paper|study|research|scholar|academic|journal)\b/i.test(query)) {
            categories.push('academic');
        }
        
        // AI相关查询
        if (/\b(ai|machine learning|deep learning|neural network|chatgpt|openai)\b/i.test(query)) {
            categories.push('ai');
        }
        
        // 通用查询
        categories.push('general');
        
        return categories;
    }
}

// 导出单例
const searchEngineManager = new SearchEngineManager();
export default searchEngineManager;
```

## 3. 技术架构

### 3.1 文件结构

```
src/
├── background/           # 后台脚本
│   └── index.js         # 后台主逻辑
├── content/             # 内容脚本
│   └── index.js         # 页面级交互
├── popup/               # 弹出窗口和侧边栏
│   ├── index.html       # 界面HTML
│   ├── main.js          # 主逻辑
│   ├── style.css        # 样式
│   └── new-style.css    # 新样式
├── settings/            # 设置页面
│   ├── index.html       # 界面HTML
│   ├── main.js          # 主逻辑
│   ├── style.css        # 样式
│   └── new-style.css    # 新样式
├── utils/               # 工具函数库
│   ├── clipboard.js     # 剪贴板操作
│   ├── communication.js # 通信工具
│   ├── linkHistory.js   # 链接历史管理
│   ├── logger.js        # 日志工具
│   ├── storage.js       # 存储管理
│   ├── textProcessor.js # 文本处理和分析
│   └── wasm/            # WebAssembly模块
│       └── jieba.wasm   # 编译为WASM的分词库
├── workers/             # Web Workers
│   ├── contentProcessor.js # 内容处理Worker
│   ├── textAnalyzer.js     # 文本分析Worker
│   └── storageWorker.js    # 存储操作Worker
└── components/          # Web Components
    ├── search-engine-selector.js # 搜索引擎选择器
    ├── clipboard-history.js      # 剪贴板历史组件
    ├── link-history.js           # 链接历史组件
    └── notification.js           # 通知组件
```

### 3.2 通信机制

- **后台脚本与内容脚本**：使用`chrome.runtime.onMessage`和`chrome.tabs.sendMessage`
- **后台脚本与弹出窗口**：使用`chrome.runtime.onMessage`和`chrome.runtime.sendMessage`
- **组件间通信**：使用`MessagePort`长连接和Custom Events
- **Worker通信**：使用`postMessage`和`onmessage`
- **存储同步**：使用`chrome.storage.local`和`chrome.storage.onChanged`监听器，结合IndexedDB

### 3.3 数据流

1. **用户输入** → 弹出窗口/侧边栏
2. **文本分析** → `textProcessor.js`或Web Worker
3. **存储操作** → `storage.js`或IndexedDB
4. **剪贴板操作** → `clipboard.js`
5. **历史记录** → `linkHistory.js`和IndexedDB
6. **后台处理** → `background/index.js`
7. **页面通知** → `content/index.js`或Web Component

## 4. 用户界面

### 4.1 弹出窗口/侧边栏

- **搜索输入框**：支持自适应高度和手动调整
- **功能开关**：提取、链接生成、多格式分析
- **剪贴板监控**：状态显示和控制
- **历史记录**：可展开/折叠的链接历史
- **剪贴板历史**：可展开/折叠的剪贴板历史
- **响应式布局**：适配不同宽度和高度
- **Web Components**：使用组件化界面，提高可维护性

### 4.2 内容脚本通知

- **页面通知**：当剪贴板内容变化时显示
- **通知样式**：滑入/滑出动画，不同类型的通知有不同颜色
- **Web Component**：使用自定义通知组件，样式统一

### 4.3 上下文菜单

- **右键菜单**：选中文本后显示"Search with Buddy"选项
- **快捷操作**：直接打开侧边栏并搜索选中的文本
- **动态菜单**：根据选中文本类型显示不同的菜单项

## 5. 键盘快捷键

| 快捷键 | 功能 |
|--------|------|
| Alt+L | 打开侧边栏 |
| Alt+K | 切换剪贴板监控 |
| Alt+Shift+S | 快速搜索选中的文本 |
| Ctrl+Shift+V | 打开剪贴板历史 |
| Ctrl+Shift+H | 打开链接历史 |

## 6. 性能优化

### 6.1 防抖处理

- **剪贴板监控**：使用防抖减少频繁的剪贴板检查
- **文本输入**：使用防抖减少频繁的文本分析和UI更新

### 6.2 懒加载和条件渲染

- **历史记录**：仅在展开时渲染历史记录
- **剪贴板历史**：仅在展开时渲染剪贴板历史
- **Web Components**：使用自定义元素的懒加载

### 6.3 批量DOM操作

- **使用文档片段**：减少DOM操作次数，提高渲染性能
- **一次性更新**：批量更新DOM，减少重绘和回流
- **虚拟列表**：对于长列表使用虚拟滚动

### 6.4 存储优化

- **历史限制**：设置历史记录数量限制，避免存储过多数据
- **去重处理**：自动移除重复的历史记录，节省存储空间
- **IndexedDB**：对于大量数据使用IndexedDB，提高存储容量和性能

### 6.5 并行处理

- **Web Workers**：将耗时操作移至Web Workers，避免阻塞主线程
- **Promise.all**：并行处理多个异步操作
- **requestAnimationFrame**：优化动画和轮询操作

## 7. 安全考虑

### 7.1 权限管理

- **最小权限原则**：仅请求必要的权限
- **可选权限**：将非必要权限设置为可选
- **权限验证**：在使用权限前检查权限状态

### 7.2 数据安全

- **内容限制**：对大内容进行截断处理，避免内存溢出
- **错误处理**：完善的错误处理机制，提高稳定性
- **输入验证**：对用户输入进行严格验证，防止注入攻击

### 7.3 隐私保护

- **本地存储**：所有数据存储在本地，不上传至服务器
- **用户控制**：用户可以随时清空历史记录和剪贴板历史
- **数据加密**：对敏感数据进行加密存储

### 7.4 内容安全策略

- **CSP**：实现严格的Content Security Policy
- **脚本验证**：验证脚本来源，防止恶意脚本执行
- **资源加载**：限制资源加载来源，防止XSS攻击

## 8. 未来扩展可能性

- **更多搜索引擎**：支持添加和管理自定义搜索引擎
- **更丰富的文本分析**：增强对更多格式的支持
- **云同步**：支持跨设备同步设置和历史记录
- **主题定制**：支持更多主题和自定义样式
- **更多集成**：与更多服务和平台集成
- **AI增强**：使用AI技术提升文本分析和推荐能力
- **插件架构**：支持第三方插件扩展功能
- **多语言支持**：支持多语言界面和文本分析

## 9. 总结

Decide search（Search Buddy）是一款功能强大的浏览器扩展，通过智能文本处理、多格式分析和高级剪贴板监控，显著增强了用户的搜索体验。其模块化设计、性能优化和用户友好的界面使其成为一个实用且高效的工具。

### 9.1 核心优势

- **智能文本处理**：支持多种文本格式的检测和处理
- **强大的剪贴板管理**：实时监控和历史记录
- **增强的链接管理**：智能分类和GitHub仓库检测
- **用户友好界面**：响应式设计和流畅的用户体验
- **性能优化**：防抖处理和懒加载，确保流畅运行
- **可扩展性**：模块化设计和插件架构，支持功能扩展
- **安全性**：完善的错误处理和隐私保护机制

### 9.2 技术亮点

- **模块化架构**：清晰的代码组织和职责分离
- **智能算法**：多种文本分析和处理算法
- **实时监控**：高效的剪贴板监控机制
- **响应式设计**：适配不同屏幕尺寸
- **WebAssembly优化**：使用WASM提高性能
- **现代Web技术**：Web Components、Web Workers、IndexedDB等
- **扩展性**：良好的扩展性和可维护性

这款扩展不仅提供了基础的搜索功能，还通过智能文本处理和剪贴板管理，为用户提供了更高效、更便捷的信息处理方式，是现代浏览器用户的得力助手。通过不断迭代和技术升级，Decide search将继续提升用户体验，成为浏览器扩展的标杆产品。